<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Cubic cell – start / reset signalling</title>

  <!-- libraries -->
  <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
  <script src="https://raw.githack.com/andreasplesch/aframe-meshline-component/master/dist/aframe-meshline-component.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/3.4.7/aframe/build/aframe-ar.js"></script>

  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{margin:0;overflow:hidden;font-family:monospace}
    #status{position:fixed;top:10px;left:10px;font-size:24px;color:#fff;z-index:1000}
    #controls{position:fixed;bottom:12px;left:12px;z-index:1000}
    #controls button{margin-right:8px;padding:6px 12px;font:16px monospace;
                     background:#222;color:#fff;border:1px solid #888;border-radius:4px;opacity:.85}
    #loader{position:fixed;inset:0;display:flex;flex-direction:column;justify-content:center;
            align-items:center;background:#000}
    .spinner{width:48px;height:48px;border:6px solid #fff;border-top-color:transparent;
             border-radius:50%;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
  </style>
</head>

<body>
  <div id="loader"><div class="spinner"></div><p style="color:#fff;margin-top:12px">Loading camera…</p></div>
  <div id="status">Searching…</div>

  <div id="controls">
    <button id="startBtn">Start signal</button>
    <button id="resetBtn">Reset signal</button>
  </div>

  <a-scene embedded arjs="sourceType: webcam; debugUIEnabled:false;">
    <a-marker id="hiroMarker" preset="hiro" emitevents="true">
      <a-entity id="cell" visible="false" drag-rotate></a-entity>
    </a-marker>
    <a-entity camera></a-entity>
  </a-scene>

  <!-- drag‑rotate -->
  <script>
    AFRAME.registerComponent('drag-rotate',{schema:{speed:{default:1}},init(){
      const cv=this.el.sceneEl.canvas;let d=false,px=0,py=0;
      const st=e=>{d=true;px=e.clientX;py=e.clientY};
      const mv=(x,y,f=1)=>{if(!d)return;const r=this.el.getAttribute('rotation');
        this.el.setAttribute('rotation',{x:r.x+(y-py)*f*this.data.speed,
                                         y:r.y+(x-px)*f*this.data.speed,z:r.z});
        px=x;py=y;};
      cv.addEventListener('mousedown',e=>st(e));
      window.addEventListener('mousemove',e=>mv(e.clientX,e.clientY));
      window.addEventListener('mouseup',()=>d=false);
      cv.addEventListener('touchstart',e=>st(e.touches[0]),{passive:false});
      window.addEventListener('touchmove',e=>{if(d){e.preventDefault();
        mv(e.touches[0].clientX,e.touches[0].clientY,0.5);}}, {passive:false});
      window.addEventListener('touchend',()=>d=false);
    }});
  </script>

  <script>
    /* handles */
    const scene=document.querySelector('a-scene');
    const marker=document.getElementById('hiroMarker');
    const cell=document.getElementById('cell');
    const status=document.getElementById('status');
    const loader=document.getElementById('loader');
    const startBtn=document.getElementById('startBtn');
    const resetBtn=document.getElementById('resetBtn');

    /* constants */
    const N=50, INTERVAL=1200, WIDTH=16;

    /* storage */
    const nodes=[], edges=[]; let timers=[];

    /* organelles */
    function addOrganelles(){
      cell.insertAdjacentHTML('beforeend',`
        <a-box width="1.6" height="1.6" depth="1.6"
               material="color:#00ffff;opacity:0.10;transparent:true;side:double"></a-box>
        <a-sphere radius="0.45"
                  material="color:#800080;opacity:0.50;transparent:true"></a-sphere>`);
      [0.55,0.42,0.34].forEach((w,i)=>{
        cell.insertAdjacentHTML('beforeend',`
          <a-box width="${w}" height="0.05" depth="${(w*0.58).toFixed(2)}"
                 position="-0.55 ${(0.25-i*0.08).toFixed(2)} 0"
                 material="color:#cd853f;opacity:0.80"></a-box>`);});
      [['0.55 -0.33 0.25','0 0 90'],['0.48 0.40 -0.30','60 30 20']]
      .forEach(m=>cell.insertAdjacentHTML('beforeend',`
          <a-cylinder radius="0.12" height="0.45"
                      position="${m[0]}" rotation="${m[1]}"
                      material="color:#ff8c00;opacity:0.85"></a-cylinder>`));
    }

    /* network */
    const rand=(a,b)=>Math.random()*(b-a)+a;
    function buildNetwork(){
      nodes.push({id:'n0',x:0,y:0.8,z:0});
      while(nodes.length<N){nodes.push({id:`n${nodes.length}`,x:rand(-0.6,0.6),y:rand(-0.6,0.6),z:rand(-0.6,0.6)})}
      nodes.forEach(n=>{
        cell.insertAdjacentHTML('beforeend',`
          <a-sphere id="${n.id}" radius="0.06" color="#888"
                    position="${n.x} ${n.y} ${n.z}"></a-sphere>`);
        n.el=document.getElementById(n.id);});
      nodes.forEach((n,i)=>{
        const list=nodes.map((m,j)=>({j,d:Math.hypot(n.x-m.x,n.y-m.y,n.z-m.z)})).sort((a,b)=>a.d-b.d);
        let add=0;for(let k=1;k<list.length&&add<3;k++){const j=list[k].j;if(j<i)continue;
          const id=`e${edges.length}`,path=`${n.x} ${n.y} ${n.z}, ${nodes[j].x} ${nodes[j].y} ${nodes[j].z}`;
          cell.insertAdjacentHTML('beforeend',`
            <a-entity id="${id}"
                      meshline="lineWidth:${WIDTH};path:${path};color:#666"></a-entity>`);
          edges.push({id,a:i,b:j,el:document.getElementById(id)});add++;}});
    }

    /* helpers */
    const colourAll=(nc,ec)=>{nodes.forEach(n=>n.el.setAttribute('color',nc));
      edges.forEach(e=>e.el.setAttribute('meshline',
        e.el.getAttribute('meshline').replace(/color:[^;]+/,`color:${ec}`)));};

    function propagate(){
      timers.forEach(clearTimeout);timers=[];
      colourAll('#888','#666');
      const visited=new Set([0]),waves=[[0]];
      while(waves[waves.length-1].length){
        const nxt=[];waves[waves.length-1].forEach(i=>{
          edges.forEach(e=>{const nb=e.a===i?e.b:e.b===i?e.a:null;
            if(nb!==null&&!visited.has(nb)){visited.add(nb);nxt.push(nb);} });});
        if(nxt.length)waves.push(nxt);else break;}
      waves.forEach((wave,w)=>{
        timers.push(setTimeout(()=>{
          wave.forEach(i=>nodes[i].el.setAttribute('color','#ff0000'));
          edges.forEach(e=>{
            if(nodes[e.a].el.getAttribute('color')==='#ff0000'&&
               nodes[e.b].el.getAttribute('color')==='#ff0000'){
              e.el.setAttribute('meshline',
                e.el.getAttribute('meshline').replace(/color:[^;]+/,'color:#ff0000'));}});},
          w*INTERVAL));});
    }
    const resetNetwork=()=>{timers.forEach(clearTimeout);timers=[];colourAll('#888','#666');};

    /* build */
    scene.addEventListener('loaded',()=>{loader.style.display='none';addOrganelles();buildNetwork();resetNetwork();});

    /* marker */
    marker.addEventListener('markerFound',()=>{cell.setAttribute('visible',true);status.textContent='Success';});
    marker.addEventListener('markerLost', ()=>{cell.setAttribute('visible',false);status.textContent='Searching…';resetNetwork();});

    /* controls */
    startBtn.addEventListener('click',()=>{if(cell.getAttribute('visible'))propagate();});
    resetBtn.addEventListener('click',()=>{resetNetwork();if(cell.getAttribute('visible'))propagate();});
  </script>
</body>
</html>
