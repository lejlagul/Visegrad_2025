<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Host-Pathogen Interaction: Signal Perturbation</title>

  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>

  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin: 0; overflow: hidden; font-family: monospace; }
    .btn {
      position: fixed;
      padding: 6px 12px;
      font: 16px monospace;
      background: #222;
      color: #fff;
      border: 1px solid #888;
      border-radius: 4px;
      opacity: 0.85;
      z-index: 1000;
      cursor: pointer;
    }
    .btn:disabled { background: #555; color: #999; cursor: not-allowed; }
    #resetBtn          { bottom: 12px; left: 12px; }
    #normalSignalBtn   { bottom: 100px; right: 12px; }
    #hijackPathBtn     { bottom: 56px; right: 12px; }
    #disruptSignalBtn  { bottom: 12px; right: 12px; }
    #zoomInBtn         { bottom: 12px; left: calc(50% - 34px); }
    #zoomOutBtn        { bottom: 12px; left: calc(50% + 2px); }
    #loader {
      position: fixed; inset: 0; display: flex; flex-direction: column;
      justify-content: center; align-items: center; background: #000;
    }
    .spinner {
      width: 48px; height: 48px; border: 6px solid #fff;
      border-top-color: transparent; border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>

<body>
  <div id="loader"><div class="spinner"></div><p style="color:#fff;margin-top:12px">Loading Biological Assets…</p></div>

  <button id="resetBtn"          class="btn">Reset</button>
  <button id="normalSignalBtn"   class="btn">Normal Signal</button>
  <button id="hijackPathBtn"     class="btn">Inject & Hijack</button>
  <button id="disruptSignalBtn"  class="btn">Inject & Disrupt</button>
  <button id="zoomInBtn"         class="btn">＋</button>
  <button id="zoomOutBtn"        class="btn">－</button>

  <a-scene background="color: #1A1A22">
    <a-light type="ambient" color="#FFF" intensity="0.5"></a-light>
    <a-light type="directional" color="#FFF" intensity="1" position="-1 2 2"></a-light>
    
    <a-entity id="cell" position="0 1.2 -7" drag-rotate scale="2 2 2"></a-entity>
    
    <a-gltf-model id="bacterium"
                  src="https://cdn.glitch.global/60126742-7663-452f-915f-363e77f525ab/bacterium.glb?v=1700239843081"
                  position="1.5 1.5 -6" scale="0.2 0.2 0.2" rotation="0 -45 0"></a-gltf-model>

    <a-entity camera position="0 1.6 0"></a-entity>
  </a-scene>

  <script>
    // Drag-to-rotate component remains the same
    AFRAME.registerComponent('drag-rotate', {
      schema: { speed: { default: 1 } },
      init() {
        const cvs = this.el.sceneEl.canvas;
        let dragging = false, px = 0, py = 0;
        const start = e => { dragging = true; px = e.clientX; py = e.clientY; };
        const move = (x, y, f = 1) => {
          if (!dragging) return;
          const r = this.el.getAttribute('rotation');
          this.el.setAttribute('rotation', {
            x: r.x + (y - py) * f * this.data.speed,
            y: r.y + (x - px) * f * this.data.speed,
            z: r.z
          });
          px = x; py = y;
        };
        cvs.addEventListener('mousedown', e => start(e));
        window.addEventListener('mousemove', e => move(e.clientX, e.clientY));
        window.addEventListener('mouseup', () => dragging = false);
        cvs.addEventListener('touchstart', e => start(e.touches[0]), { passive: false });
        window.addEventListener('touchmove', e => {
          if (dragging) { e.preventDefault(); move(e.touches[0].clientX, e.touches[0].clientY, 0.5); }
        }, { passive: false });
        window.addEventListener('touchend', () => dragging = false);
      }
    });
  </script>

  <script>
    /* === HANDLES & CONSTANTS === */
    const cellEl          = document.getElementById('cell'),
          loader          = document.getElementById('loader'),
          normalSignalBtn = document.getElementById('normalSignalBtn'),
          hijackPathBtn   = document.getElementById('hijackPathBtn'),
          disruptSignalBtn= document.getElementById('disruptSignalBtn'),
          resetBtn        = document.getElementById('resetBtn'),
          zoomInBtn       = document.getElementById('zoomInBtn'),
          zoomOutBtn      = document.getElementById('zoomOutBtn');

    const N_NODES = 200, N_ENDPOINTS = 5, PROP_INTERVAL = 400,
          NETWORK_RADIUS = 0.005, SCALE_MIN = 1, SCALE_MAX = 5;
    let currentScale = 2, effectorCount = 0;

    const nodes = [], edges = [], endpointIdx = [], timers = [], organelles = [];
    const NUCLEUS_CENTER = new THREE.Vector3(0, -0.1, 0);

    /* === ZOOM HELPERS (Unchanged) === */
    function setCellScale(s) {
      currentScale = Math.min(Math.max(s, SCALE_MIN), SCALE_MAX);
      cellEl.setAttribute('scale', `${currentScale} ${currentScale} ${currentScale}`);
    }
    zoomInBtn.onclick = () => setCellScale(currentScale * 1.2);
    zoomOutBtn.onclick = () => setCellScale(currentScale / 1.2);
    // ... (rest of zoom/pinch listeners are unchanged) ...
    window.addEventListener('wheel', e => setCellScale(currentScale * (e.deltaY < 0 ? 1.1 : 0.9)), { passive: true });
    let pinchStart = null;
    window.addEventListener('touchmove', e => {
      if (e.touches.length === 2) {
        const [a, b] = e.touches, d = Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY);
        if (pinchStart === null) pinchStart = d;
        else { setCellScale(currentScale * (d / pinchStart)); pinchStart = d; }
        e.preventDefault();
      }
    }, { passive: false });
    window.addEventListener('touchend', () => pinchStart = null);


    /* === CYLINDER HELPER (Unchanged) === */
    function addCylinder(aVec, bVec, radius, color, parent) {
      const mid = aVec.clone().add(bVec).multiplyScalar(0.5);
      const len = aVec.distanceTo(bVec);
      const id = `cyl-${Math.random().toString(36).slice(2)}`;
      parent.insertAdjacentHTML('beforeend',
        `<a-cylinder id="${id}" position="${mid.x} ${mid.y} ${mid.z}"
                    radius="${radius}" height="${len}" color="${color}"
                    material="opacity:0.9; shader:flat;"></a-cylinder>`);
      document.getElementById(id).object3D.quaternion.setFromUnitVectors(
        new THREE.Vector3(0, 1, 0),
        bVec.clone().sub(aVec).normalize()
      );
    }
    
    /* === ADD REALISTIC ORGANELLES === */
    function addOrganelles() {
        // Cell Membrane
        cellEl.insertAdjacentHTML('beforeend', `
            <a-gltf-model src="https://cdn.glitch.global/60126742-7663-452f-915f-363e77f525ab/cell_membrane.glb?v=1700239848727"
                          scale="0.8 0.8 0.8"
                          material="opacity: 0.15; transparent: true;"></a-gltf-model>`);

        // Nucleus
        cellEl.insertAdjacentHTML('beforeend', `
            <a-gltf-model src="https://cdn.glitch.global/60126742-7663-452f-915f-363e77f525ab/dna_molecule.glb?v=1680012945899"
                          position="${NUCLEUS_CENTER.x} ${NUCLEUS_CENTER.y} ${NUCLEUS_CENTER.z}"
                          scale="0.2 0.2 0.2"></a-gltf-model>`);
        organelles.push({ center: NUCLEUS_CENTER, radius: 0.25 });

        // Endoplasmic Reticulum
        cellEl.insertAdjacentHTML('beforeend', `
            <a-gltf-model src="https://cdn.glitch.global/60126742-7663-452f-915f-363e77f525ab/endoplasmic_reticulum.glb?v=1700239857313"
                          position="0.1 -0.15 0.3" scale="0.3 0.3 0.3" rotation="0 20 0"></a-gltf-model>`);
        organelles.push({ center: new THREE.Vector3(0.1, -0.15, 0.3), radius: 0.2 });
      
        // Golgi Apparatus
        cellEl.insertAdjacentHTML('beforeend', `
            <a-gltf-model src="https://cdn.glitch.global/60126742-7663-452f-915f-363e77f525ab/golgi_apparatus.glb?v=1700239859521"
                          position="-0.35 0.1 0.1" scale="0.25 0.25 0.25" rotation="0 -30 0"></a-gltf-model>`);
        organelles.push({ center: new THREE.Vector3(-0.35, 0.1, 0.1), radius: 0.15 });

        // Mitochondria (add several randomly)
        for (let i = 0; i < 5; i++) {
            const pos = { x: Math.random() - 0.5, y: Math.random() - 0.5, z: Math.random() - 0.5 };
            // Ensure they don't overlap with the nucleus
            if (new THREE.Vector3(pos.x, pos.y, pos.z).distanceTo(NUCLEUS_CENTER) < 0.4) { i--; continue; }
            cellEl.insertAdjacentHTML('beforeend', `
                <a-gltf-model src="https://cdn.glitch.global/60126742-7663-452f-915f-363e77f525ab/mitochondrion.glb?v=1700239854742"
                              position="${pos.x} ${pos.y} ${pos.z}" scale="0.1 0.1 0.1"
                              rotation="${Math.random()*180} ${Math.random()*180} ${Math.random()*180}"></a-gltf-model>`);
        }
    }

    /* === BUILD SIGNALING NETWORK === */
    const rnd = (a, b) => Math.random() * (b - a) + a;
    function buildNetwork() {
      // Clear previous state
      cellEl.innerHTML = '';
      nodes.length = edges.length = endpointIdx.length = organelles.length = 0;
      
      addOrganelles();
      
      // The "receptor" node on the cell surface
      nodes.push({ id: 'n0', x: 0, y: 0.5, z: 0, type: 'receptor' });
      
      // Endpoint nodes inside the nucleus, representing transcription factors
      const dnaRadius = 0.1, dnaHeight = 0.2;
      for (let i = 0; i < N_ENDPOINTS; i++) {
        const angle = (i / N_ENDPOINTS) * Math.PI * 2;
        const y_offset = rnd(-dnaHeight/2, dnaHeight/2);
        const x = dnaRadius * Math.cos(angle) + NUCLEUS_CENTER.x;
        const y = y_offset + NUCLEUS_CENTER.y;
        const z = dnaRadius * Math.sin(angle) + NUCLEUS_CENTER.z;
        endpointIdx.push(nodes.length);
        nodes.push({ id: `n${nodes.length}`, x, y, z, type: 'endpoint' });
      }

      // Generate the rest of the network nodes (e.g., kinases, second messengers)
      while (nodes.length < N_NODES) {
        const x = rnd(-0.6, 0.6), y = rnd(-0.6, 0.6), z = rnd(-0.6, 0.6);
        let inOrganelle = false;
        for (const org of organelles) {
            if (new THREE.Vector3(x, y, z).distanceTo(org.center) < org.radius) {
                inOrganelle = true;
                break;
            }
        }
        if (inOrganelle) continue; // Don't place nodes inside organelles
        nodes.push({ id: `n${nodes.length}`, x, y, z, type: 'relay' });
      }
      
      // Create visual spheres for each node
      nodes.forEach(n => {
        const r = n.type === 'relay' ? 0.025 : 0.04;
        const c = n.type === 'receptor' ? '#FFFF00' : n.type === 'endpoint' ? '#00FF00' : '#BBBBBB';
        cellEl.insertAdjacentHTML('beforeend',
          `<a-sphere id="${n.id}" radius="${r}" color="${c}"
                     position="${n.x} ${n.y} ${n.z}"
                     material="shader: flat;"></a-sphere>`);
        n.el = document.getElementById(n.id);
      });
      
      // Connect nodes to form the network
      nodes.forEach((n, i) => {
        const dists = nodes.map((m, j) => ({ j, dist: Math.hypot(n.x - m.x, n.y - m.y, n.z - m.z) }))
          .sort((a, b) => a.dist - b.dist);
        let added = 0;
        for (let k = 1; k < dists.length && added < 3; k++) {
          const j = dists[k].j; if (j < i) continue;
          addCylinder(
            new THREE.Vector3(n.x, n.y, n.z),
            new THREE.Vector3(nodes[j].x, nodes[j].y, nodes[j].z),
            NETWORK_RADIUS, '#AAAAAA', cellEl);
          edges.push({ a: i, b: j, el: cellEl.lastElementChild });
          added++;
        }
      });
    }

    /* === COLOR & RESET HELPERS === */
    function setNodeColour(n, c) { n.el.setAttribute('color', c); }
    function resetNetwork() {
      timers.forEach(clearTimeout);
      timers.length = 0;
      // Reset node and edge colors
      nodes.forEach(n => {
        const c = n.type === 'receptor' ? '#FFFF00' : n.type === 'endpoint' ? '#00FF00' : '#BBBBBB';
        setNodeColour(n, c);
      });
      edges.forEach(e => e.el.setAttribute('color', '#AAAAAA'));
      // Remove old effector proteins
      document.querySelectorAll('[id^="effector-"]').forEach(p => p.remove());
      // Re-enable buttons
      [normalSignalBtn, hijackPathBtn, disruptSignalBtn].forEach(btn => btn.disabled = false);
    }
    
    /* === SIGNALING ALGORITHMS === */
    // Generic pathfinder using Breadth-First Search
    function findPath(startNode, endNodes) {
        const adj = Array(nodes.length).fill().map(() => []);
        edges.forEach(e => { adj[e.a].push(e.b); adj[e.b].push(e.a); });
        
        const q = [startNode];
        const prev = Array(nodes.length).fill(-1);
        const dist = Array(nodes.length).fill(Infinity);
        dist[startNode] = 0;
        let foundCount = 0;

        while(q.length > 0 && foundCount < endNodes.length) {
            const u = q.shift();
            if (endNodes.includes(u)) foundCount++;
            for (const v of adj[u]) {
                if (dist[v] === Infinity) {
                    dist[v] = dist[u] + 1;
                    prev[v] = u;
                    q.push(v);
                }
            }
        }
        return { dist, prev };
    }

    // Animate a signal along a specific path
    function animateSignal(pathData, targetNodes, color) {
        const allPaths = new Set();
        const edgeMap = new Map();
        edges.forEach((e, i) => edgeMap.set(`${Math.min(e.a,e.b)}-${Math.max(e.a,e.b)}`, e.el));

        targetNodes.forEach(target => {
            for (let u = target; u !== -1; u = pathData.prev[u]) {
                allPaths.add(u);
                const p = pathData.prev[u];
                if (p !== -1) {
                    const edgeEl = edgeMap.get(`${Math.min(u,p)}-${Math.max(u,p)}`);
                    if(edgeEl) allPaths.add(edgeEl);
                }
            }
        });

        const maxStep = Math.max(...targetNodes.map(n => pathData.dist[n]));
        for (let s = 0; s <= maxStep; s++) {
            timers.push(setTimeout(() => {
                nodes.forEach((node, i) => {
                    if (pathData.dist[i] === s && allPaths.has(i)) {
                        setNodeColour(node, color);
                    }
                });
                edges.forEach(e => {
                    if (pathData.dist[e.a] < s && pathData.dist[e.b] < s && allPaths.has(e.el)) {
                       e.el.setAttribute('color', color);
                    }
                });
            }, s * PROP_INTERVAL));
        }
    }

    // Propagate signal through the entire network (diffusion)
    function propagateDiffuse(startNode, color) {
        const waves = [[startNode]];
        const visited = new Set([startNode]);
        while(waves[waves.length-1].length > 0) {
            const nextWave = [];
            waves[waves.length-1].forEach(u => {
                edges.forEach(e => {
                    const v = e.a === u ? e.b : (e.b === u ? e.a : null);
                    if (v !== null && !visited.has(v)) {
                        visited.add(v);
                        nextWave.push(v);
                    }
                });
            });
            if (nextWave.length > 0) waves.push(nextWave); else break;
        }

        waves.forEach((wave, i) => {
            timers.push(setTimeout(() => {
                wave.forEach(nodeIdx => setNodeColour(nodes[nodeIdx], color));
                edges.forEach(e => {
                    if (nodes[e.a].el.getAttribute('color') === color && nodes[e.b].el.getAttribute('color') === color) {
                        e.el.setAttribute('color', color);
                    }
                });
            }, i * PROP_INTERVAL));
        });
    }

    /* === BACTERIAL EFFECTOR INJECTION === */
    function injectEffector() {
      const id = `effector-${effectorCount++}`;
      // Animate from bacterium to the cell surface receptor
      cellEl.insertAdjacentHTML('beforeend',
        `<a-sphere id="${id}" radius="0.04" color="#FF00FF" position="0.75 0.5 0"
                  animation="property: position; to: 0 0.5 0; dur: 2000;
                             easing: easeInCubic; fill: forwards"></a-sphere>`);
      return 2000; // Return animation duration
    }

    /* === LIFECYCLE & UI ACTIONS === */
    document.querySelector('a-scene').addEventListener('loaded', () => {
      loader.style.display = 'none';
      buildNetwork();
    });
    
    resetBtn.onclick = () => resetNetwork();

    normalSignalBtn.onclick = () => {
        resetNetwork();
        [normalSignalBtn, hijackPathBtn, disruptSignalBtn].forEach(btn => btn.disabled = true);
        const pathData = findPath(endpointIdx[0], [0]); // Signal from one nucleus point to receptor
        animateSignal(pathData, [0], '#00BFFF'); // Blue "healthy" signal
    };

    hijackPathBtn.onclick = () => {
      resetNetwork();
      [normalSignalBtn, hijackPathBtn, disruptSignalBtn].forEach(btn => btn.disabled = true);
      const delay = injectEffector();
      timers.push(setTimeout(() => {
          const pathData = findPath(0, endpointIdx); // Signal from receptor to all nucleus points
          animateSignal(pathData, endpointIdx, '#FF0000'); // Red "hijacked" signal
      }, delay));
    };

    disruptSignalBtn.onclick = () => {
      resetNetwork();
      [normalSignalBtn, hijackPathBtn, disruptSignalBtn].forEach(btn => btn.disabled = true);
      const delay = injectEffector();
      timers.push(setTimeout(() => {
          propagateDiffuse(0, '#FF4500'); // Orange "disrupted" signal
      }, delay));
    };

  </script>
</body>
</html>
