<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Cubic cell – spaced nodes</title>

  <!-- A‑Frame, AR.js and meshline -->
  <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/3.4.7/aframe/build/aframe-ar.js"></script>
  <script src="https://raw.githack.com/spite/aframe-meshline-component/master/dist/aframe-meshline-component.min.js"></script>

  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{margin:0;overflow:hidden;font-family:monospace}

    #status{position:fixed;top:10px;left:10px;font-size:24px;color:#fff;z-index:1000}

    #resetBtn,#startBtn,#zoomInBtn,#zoomOutBtn{
      position:fixed;padding:6px 12px;font:16px monospace;
      background:#222;color:#fff;border:1px solid #888;border-radius:4px;
      opacity:0.85;z-index:1000}

    #resetBtn{bottom:12px;left:12px}
    #startBtn{bottom:12px;right:12px;display:none}

    #zoomInBtn,#zoomOutBtn{bottom:12px}
    #zoomInBtn{left:calc(50% - 34px)}
    #zoomOutBtn{left:calc(50% + 2px)}

    #loader{position:fixed;inset:0;display:flex;flex-direction:column;justify-content:center;
            align-items:center;background:#000}
    .spinner{width:48px;height:48px;border:6px solid #fff;border-top-color:transparent;
             border-radius:50%;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
  </style>
</head>

<body>
  <div id="loader">
    <div class="spinner"></div>
    <p style="color:#fff;margin-top:12px">Loading camera…</p>
  </div>

  <div id="status">Searching…</div>
  <button id="resetBtn">Reset signal</button>
  <button id="startBtn">Start animation</button>
  <button id="zoomInBtn">＋</button>
  <button id="zoomOutBtn">－</button>

  <a-scene embedded arjs="sourceType: webcam; debugUIEnabled:false;">
    <a-marker id="hiroMarker" preset="hiro" emitevents="true">
      <a-entity id="cell" visible="false" drag-rotate scale="4 4 4"></a-entity>
    </a-marker>
    <a-entity id="cam" camera></a-entity>
  </a-scene>

  <!-- drag‑rotate (unchanged) -->
  <script>
    AFRAME.registerComponent('drag-rotate', {
      schema:{speed:{default:1}},
      init(){
        const cvs=this.el.sceneEl.canvas;
        let dragging=false,px=0,py=0;
        const start=e=>{dragging=true;px=e.clientX;py=e.clientY;};
        const move=(x,y,f=1)=>{
          if(!dragging)return;
          const r=this.el.getAttribute('rotation');
          this.el.setAttribute('rotation',{
            x:r.x+(y-py)*f*this.data.speed,
            y:r.y+(x-px)*f*this.data.speed,
            z:r.z});
          px=x;py=y;
        };
        cvs.addEventListener('mousedown',e=>start(e));
        window.addEventListener('mousemove',e=>move(e.clientX,e.clientY));
        window.addEventListener('mouseup',()=>dragging=false);
        cvs.addEventListener('touchstart',e=>start(e.touches[0]),{passive:false});
        window.addEventListener('touchmove',e=>{
          if(dragging){e.preventDefault();move(e.touches[0].clientX,e.touches[0].clientY,0.5);}},{passive:false});
        window.addEventListener('touchend',()=>dragging=false);
      }
    });
  </script>

  <script>
    /******** Handles & constants ********/
    const scene=document.querySelector('a-scene'),
          marker=document.getElementById('hiroMarker'),
          cell=document.getElementById('cell'),
          statusTxt=document.getElementById('status'),
          loader=document.getElementById('loader'),
          resetBtn=document.getElementById('resetBtn'),
          startBtn=document.getElementById('startBtn'),
          zoomInBtn=document.getElementById('zoomInBtn'),
          zoomOutBtn=document.getElementById('zoomOutBtn');

    const N_NODES=150,
          N_ENDPOINTS=4,
          PROP_INTERVAL=900,
          SCALE_MIN=1,
          SCALE_MAX=10;
    let currentScale=4;

    const nodes=[],edges=[],endpointIdx=[],timers=[];

    /******** Zoom (unchanged) ********/
    function setCellScale(s){
      currentScale=Math.min(Math.max(s,SCALE_MIN),SCALE_MAX);
      cell.setAttribute('scale',`${currentScale} ${currentScale} ${currentScale}`);
    }
    zoomInBtn.onclick =()=>setCellScale(currentScale*1.2);
    zoomOutBtn.onclick=()=>setCellScale(currentScale/1.2);
    window.addEventListener('wheel',e=>setCellScale(currentScale*(e.deltaY<0?1.1:0.9)),{passive:true});
    let pinchStart=null;
    window.addEventListener('touchmove',e=>{
      if(e.touches.length===2){
        const [a,b]=e.touches,
              d=Math.hypot(a.clientX-b.clientX,a.clientY-b.clientY);
        if(pinchStart===null) pinchStart=d;
        else{setCellScale(currentScale*(d/pinchStart));pinchStart=d;}
        e.preventDefault();
      }
    },{passive:false});
    window.addEventListener('touchend',()=>pinchStart=null);

    /******** Static organelles (unchanged) ********/
    function addOrganelles(){
      const h=0.8, EDGE_WIDTH=0.08, EDGE_COLOR='#000';
      const seg=[[[-h,-h,-h],[-h, h,-h]],[[ h,-h,-h],[ h, h,-h]],
                 [[-h,-h, h],[-h, h, h]],[[ h,-h, h],[ h, h, h]],
                 [[-h, h,-h],[ h, h,-h]],[[ h, h,-h],[ h, h, h]],
                 [[ h, h, h],[-h, h, h]],[[-h, h, h],[-h, h,-h]],
                 [[-h,-h,-h],[ h,-h,-h]],[[ h,-h,-h],[ h,-h, h]],
                 [[ h,-h, h],[-h,-h, h]],[[-h,-h, h],[-h,-h,-h]]];
      seg.forEach(p=>{
        cell.insertAdjacentHTML('beforeend',
          `<a-entity meshline="path:${p[0].join(' ')},${p[1].join(' ')};color:${EDGE_COLOR};lineWidth:${EDGE_WIDTH};sizeAttenuation:true;worldUnits:true"></a-entity>`);
      });
      const nY=-0.55;
      cell.insertAdjacentHTML('beforeend',`
        <a-sphere radius="0.25" position="0 ${nY} 0"
                  material="color:#800080;opacity:0.5;transparent:true;side:double"></a-sphere>
        <a-sphere radius="0.28" position="0 ${nY} 0"
                  material="color:#dda0dd;opacity:0.2;transparent:true;side:double"></a-sphere>`);
      [0.55,0.42,0.34].forEach((w,i)=>{
        cell.insertAdjacentHTML('beforeend',
          `<a-box width="${w}" height="0.05" depth="${(w*0.58).toFixed(3)}"
                  position="-0.55 ${(0.25-i*0.08).toFixed(2)} 0"
                  material="color:#cd853f;opacity:0.8"></a-box>`);
      });
    }

    /******** Cytoskeleton (unchanged) ********/
    function addCytoskeleton(){
      const rnd=(a,b)=>Math.random()*(b-a)+a;
      for(let i=0;i<90;i++){
        const a=[rnd(-0.75,0.75),rnd(-0.75,0.75),rnd(-0.75,0.75)],
              b=[rnd(-0.75,0.75),rnd(-0.75,0.75),rnd(-0.75,0.75)];
        cell.insertAdjacentHTML('beforeend',
          `<a-entity line="start:${a.join(' ')};end:${b.join(' ')};color:#00ffff;transparent:true;opacity:0.3"></a-entity>`);
      }
    }

    /******** Network generation (node radii reduced) ********/
    const rnd=(a,b)=>Math.random()*(b-a)+a;
    function buildNetwork(){
      /* blue start node */
      const startY=0.9;
      nodes.push({id:'n0',x:0,y:startY,z:0,type:'star'});

      /* nucleus params */
      const nC={x:0,y:-0.55,z:0}, nR=0.30;

      /* green endpoints inside nucleus */
      while(endpointIdx.length<N_ENDPOINTS){
        let x,y,z;
        do{
          x=rnd(-nR*0.9,nR*0.9);
          y=rnd(-nR*0.9,nR*0.9)+nC.y;
          z=rnd(-nR*0.9,nR*0.9);
        }while(Math.hypot(x-nC.x,y-nC.y,z-nC.z)>nR*0.9);
        endpointIdx.push(nodes.length);
        nodes.push({id:`n${nodes.length}`,x,y,z,type:'endpoint'});
      }

      /* rest of nodes */
      while(nodes.length<N_NODES){
        const x=rnd(-0.6,0.6),y=rnd(-0.6,0.6),z=rnd(-0.6,0.6);
        if(Math.hypot(x-nC.x,y-nC.y,z-nC.z)<nR) continue;
        nodes.push({id:`n${nodes.length}`,x,y,z,type:'sphere'});
      }

      /* visuals with new radii */
      nodes.forEach(n=>{
        if(n.type==='star'){
          cell.insertAdjacentHTML('beforeend',
            `<a-sphere id="${n.id}" radius="0.06" color="#0000ff"
                       position="${n.x} ${n.y} ${n.z}"></a-sphere>`);
        }else if(n.type==='endpoint'){
          cell.insertAdjacentHTML('beforeend',
            `<a-sphere id="${n.id}" radius="0.06" color="#00ff00"
                       position="${n.x} ${n.y} ${n.z}"></a-sphere>`);
        }else{
          cell.insertAdjacentHTML('beforeend',
            `<a-sphere id="${n.id}" radius="0.04" color="#888"
                       position="${n.x} ${n.y} ${n.z}"></a-sphere>`);
        }
        n.el=document.getElementById(n.id);
      });

      /* edges */
      nodes.forEach((n,i)=>{
        const dists=nodes.map((m,j)=>({j,dist:Math.hypot(n.x-m.x,n.y-m.y,n.z-m.z)})).sort((a,b)=>a.dist-b.dist);
        let added=0;
        for(let k=1;k<dists.length&&added<3;k++){
          const j=dists[k].j;if(j<i)continue;
          const id=`e${edges.length}`;
          cell.insertAdjacentHTML('beforeend',
            `<a-entity id="${id}" line="start:${n.x} ${n.y} ${n.z};end:${nodes[j].x} ${nodes[j].y} ${nodes[j].z};color:#666"></a-entity>`);
          edges.push({id,a:i,b:j,el:document.getElementById(id)});
          added++;
        }
      });
    }

    /******** Colour helpers (unchanged) ********/
    function setNodeColour(node,col){node.el.setAttribute('color',col);}
    function resetColours(base='#666'){
      nodes.forEach(n=>{
        let col=base;
        if(n.type==='star') col='#0000ff';
        else if(n.type==='endpoint') col='#00ff00';
        setNodeColour(n,col);
      });
      edges.forEach(e=>e.el.setAttribute('line',`color:${base}`));
    }

    /******** Path‑limited propagation (unchanged) ********/
    function propagate(){
      timers.forEach(clearTimeout);timers.length=0;
      resetColours('#888');

      const adj=Array(nodes.length).fill().map(()=>[]);
      const edgeMap=new Map();
      edges.forEach((e,i)=>{
        adj[e.a].push(e.b);adj[e.b].push(e.a);
        edgeMap.set(`${Math.min(e.a,e.b)}-${Math.max(e.a,e.b)}`,i);
      });

      const start=0,prev=new Array(nodes.length).fill(-1),dist=new Array(nodes.length).fill(Infinity);
      const q=[start];dist[start]=0;let found=0;
      while(q.length&&found<endpointIdx.length){
        const u=q.shift();
        adj[u].forEach(v=>{
          if(dist[v]!==Infinity)return;
          prev[v]=u;dist[v]=dist[u]+1;q.push(v);
          if(endpointIdx.includes(v))found++;
        });
      }

      const pathNodes=new Set([start]),pathEdges=new Set();
      endpointIdx.forEach(ep=>{
        let u=ep;
        while(u!==start&&u!==-1){
          pathNodes.add(u);
          const p=prev[u],key=`${Math.min(u,p)}-${Math.max(u,p)}`;
          if(edgeMap.has(key))pathEdges.add(edgeMap.get(key));
          u=p;
        }
      });

      const pathDist={},toVisit=[start];pathNodes.forEach(i=>pathDist[i]=Infinity);pathDist[start]=0;
      while(toVisit.length){
        const u=toVisit.shift();
        adj[u].forEach(v=>{
          if(!pathNodes.has(v)||pathDist[v]!==Infinity)return;
          if(pathEdges.has(edgeMap.get(`${Math.min(u,v)}-${Math.max(u,v)}`))){
            pathDist[v]=pathDist[u]+1;toVisit.push(v);
          }
        });
      }
      const maxStep=Math.max(...Object.values(pathDist));

      for(let s=0;s<=maxStep;s++){
        timers.push(setTimeout(()=>{
          Object.entries(pathDist).forEach(([i,d])=>{
            if(d===s)setNodeColour(nodes[i],'#ff0000');
          });
          pathEdges.forEach(ei=>{
            const e=edges[ei];
            if(pathDist[e.a]<=s&&pathDist[e.b]<=s)
              e.el.setAttribute('line','color:#ff0000');
          });
        },s*PROP_INTERVAL));
      }
    }
    const resetNetwork=()=>{timers.forEach(clearTimeout);timers.length=0;resetColours('#666');};

    /******** Lifecycle ********/
    scene.addEventListener('loaded',()=>{
      loader.style.display='none';
      addOrganelles();addCytoskeleton();buildNetwork();
    });
    marker.addEventListener('markerFound',()=>{
      cell.setAttribute('visible',true);
      statusTxt.textContent='Success';
      startBtn.style.display='block';
    });
    marker.addEventListener('markerLost',()=>{
      cell.setAttribute('visible',false);
      statusTxt.textContent='Searching…';
      startBtn.style.display='none';
      resetNetwork();
    });
    startBtn.onclick=()=>{propagate();startBtn.style.display='none';};
    resetBtn.onclick =()=>{resetNetwork();propagate();};
  </script>
</body>
</html>
