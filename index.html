<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Cubic cell – 150‑node network (zoomable)</title>

  <!-- A‑Frame, AR.js and meshline -->
  <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/3.4.7/aframe/build/aframe-ar.js"></script>
  <script src="https://raw.githack.com/spite/aframe-meshline-component/master/dist/aframe-meshline-component.min.js"></script>

  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{margin:0;overflow:hidden;font-family:monospace}

    #status{position:fixed;top:10px;left:10px;font-size:24px;color:#fff;z-index:1000}

    #resetBtn,#startBtn,#zoomInBtn,#zoomOutBtn{
      position:fixed;padding:6px 12px;font:16px monospace;
      background:#222;color:#fff;border:1px solid #888;border-radius:4px;
      opacity:0.85;z-index:1000}

    #resetBtn{bottom:12px;left:12px}
    #startBtn{bottom:12px;right:12px;display:none}

    /* zoom buttons sit together in the centre‑bottom */
    #zoomInBtn,#zoomOutBtn{bottom:12px}
    #zoomInBtn{left:calc(50% - 34px)}
    #zoomOutBtn{left:calc(50% + 2px)}

    #loader{position:fixed;inset:0;display:flex;flex-direction:column;justify-content:center;
            align-items:center;background:#000}
    .spinner{width:48px;height:48px;border:6px solid #fff;border-top-color:transparent;
             border-radius:50%;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
  </style>
</head>

<body>
  <div id="loader">
    <div class="spinner"></div>
    <p style="color:#fff;margin-top:12px">Loading camera…</p>
  </div>

  <div id="status">Searching…</div>
  <button id="resetBtn">Reset signal</button>
  <button id="startBtn">Start animation</button>
  <button id="zoomInBtn">＋</button>
  <button id="zoomOutBtn">－</button>

  <a-scene embedded arjs="sourceType: webcam; debugUIEnabled:false;">
    <a-marker id="hiroMarker" preset="hiro" emitevents="true">
      <!-- doubled in size (scale 4) -->
      <a-entity id="cell" visible="false" drag-rotate scale="4 4 4"></a-entity>
    </a-marker>
    <a-entity id="cam" camera></a-entity>
  </a-scene>

  <!-- drag‑rotate component -->
  <script>
    AFRAME.registerComponent('drag-rotate', {
      schema: { speed: { default: 1 } },
      init() {
        const cvs = this.el.sceneEl.canvas;
        let dragging = false, px = 0, py = 0;
        const start = e => { dragging = true; px = e.clientX; py = e.clientY; };
        const move  = (x,y,f=1) => {
          if (!dragging) return;
          const r = this.el.getAttribute('rotation');
          this.el.setAttribute('rotation',{
            x:r.x+(y-py)*f*this.data.speed,
            y:r.y+(x-px)*f*this.data.speed,
            z:r.z});
          px = x; py = y;
        };
        cvs.addEventListener('mousedown',e=>start(e));
        window.addEventListener('mousemove',e=>move(e.clientX,e.clientY));
        window.addEventListener('mouseup',()=>dragging=false);
        cvs.addEventListener('touchstart',e=>start(e.touches[0]),{passive:false});
        window.addEventListener('touchmove',e=>{
          if(dragging){e.preventDefault();move(e.touches[0].clientX,e.touches[0].clientY,0.5);} },{passive:false});
        window.addEventListener('touchend',()=>dragging=false);
      }
    });
  </script>

  <script>
    /******** Handles & constants ********/
    const scene    = document.querySelector('a-scene');
    const marker   = document.getElementById('hiroMarker');
    const cell     = document.getElementById('cell');
    const statusTxt= document.getElementById('status');
    const loader   = document.getElementById('loader');
    const resetBtn = document.getElementById('resetBtn');
    const startBtn = document.getElementById('startBtn');
    const zoomInBtn= document.getElementById('zoomInBtn');
    const zoomOutBtn=document.getElementById('zoomOutBtn');

    const N_NODES       = 150;   // total (including the star)
    const PROP_INTERVAL = 1200;  // ms between propagation waves
    const SCALE_MIN     = 1;
    const SCALE_MAX     = 10;
    let   currentScale  = 4;     // matches initial scale attribute

    /* data stores */
    const nodes = [], edges = [];
    let timers  = [];

    /******** Zoom helpers ********/
    function setCellScale(s){
      currentScale = Math.min(Math.max(s, SCALE_MIN), SCALE_MAX);
      const v = `${currentScale} ${currentScale} ${currentScale}`;
      cell.setAttribute('scale', v);
    }
    zoomInBtn.addEventListener('click',  () => setCellScale(currentScale * 1.2));
    zoomOutBtn.addEventListener('click', () => setCellScale(currentScale / 1.2));

    /* mouse‑wheel / track‑pad */
    window.addEventListener('wheel', e => {
      const dir = e.deltaY < 0 ? 1 : -1;   // up=zoom in, down=zoom out
      setCellScale(currentScale * (dir>0 ? 1.1 : 0.9));
    }, {passive:true});

    /* pinch‑to‑zoom (basic) */
    let pinchStartDist = null;
    window.addEventListener('touchmove', e=>{
      if(e.touches.length===2){
        const [t0,t1]=e.touches;
        const d = Math.hypot(t0.clientX-t1.clientX, t0.clientY-t1.clientY);
        if(pinchStartDist===null) pinchStartDist=d;
        else{
          const factor = d / pinchStartDist;
          setCellScale(currentScale * factor);
          pinchStartDist=d;  // reset for next frame
        }
        e.preventDefault();
      }
    }, {passive:false});
    window.addEventListener('touchend',()=>{ pinchStartDist=null; });

    /******** Static organelles (walls, nucleus, Golgi) ********/
    function addOrganelles(){
      /* cube “cell wall” – thick black mesh lines */
      const h = 0.8;
      const EDGE_WIDTH = 0.08;
      const EDGE_COLOR = '#000';

      const seg = [[[-h,-h,-h],[-h, h,-h]], [[ h,-h,-h],[ h, h,-h]],
                   [[-h,-h, h],[-h, h, h]], [[ h,-h, h],[ h, h, h]],
                   [[-h, h,-h],[ h, h,-h]], [[ h, h,-h],[ h, h, h]],
                   [[ h, h, h],[-h, h, h]], [[-h, h, h],[-h, h,-h]],
                   [[-h,-h,-h],[ h,-h,-h]], [[ h,-h,-h],[ h,-h, h]],
                   [[ h,-h, h],[-h,-h, h]], [[-h,-h, h],[-h,-h,-h]]];
      seg.forEach(p=>{
        const s = p[0].join(' '), e = p[1].join(' ');
        cell.insertAdjacentHTML('beforeend',
          `<a-entity meshline="path: ${s}, ${e}; color: ${EDGE_COLOR}; lineWidth: ${EDGE_WIDTH}; sizeAttenuation: true; worldUnits: true"></a-entity>`);
      });

      /* nucleus + membrane */
      const nY = -0.55;
      cell.insertAdjacentHTML('beforeend',`
        <a-sphere radius="0.25" position="0 ${nY} 0"
                  material="color:#800080;opacity:0.5;transparent:true;side:double"></a-sphere>
        <a-sphere radius="0.28" position="0 ${nY} 0"
                  material="color:#dda0dd;opacity:0.2;transparent:true;side:double"></a-sphere>
      `);

      /* Golgi bodies */
      [0.55,0.42,0.34].forEach((w,i)=>{
        cell.insertAdjacentHTML('beforeend',
          `<a-box width="${w}" height="0.05" depth="${(w*0.58).toFixed(3)}"
                  position="-0.55 ${(0.25-i*0.08).toFixed(2)} 0"
                  material="color:#cd853f;opacity:0.8"></a-box>`);
      });
    }

    /******** Cytoskeleton (random cyan filaments) ********/
    function addCytoskeleton(){
      const rnd=(a,b)=>Math.random()*(b-a)+a;
      for(let i=0;i<90;i++){
        const a=[rnd(-0.75,0.75), rnd(-0.75,0.75), rnd(-0.75,0.75)];
        const b=[rnd(-0.75,0.75), rnd(-0.75,0.75), rnd(-0.75,0.75)];
        cell.insertAdjacentHTML('beforeend',
          `<a-entity line="start:${a.join(' ')}; end:${b.join(' ')}; color:#00ffff;transparent:true;opacity:0.3"></a-entity>`);
      }
    }

    /******** Network generation ********/
    const rnd=(a,b)=>Math.random()*(b-a)+a;
    function buildNetwork(){
      /* START NODE – bright yellow star billboard at top centre */
      const startY = 0.9;
      nodes.push({id:'n0',x:0,y:startY,z:0,type:'star'});

      /* block around nucleus – avoid inside bottom nucleus */
      const nC={x:0,y:-0.55,z:0}, nR=0.30;

      /* fill the rest with random nodes */
      while(nodes.length<N_NODES){
        const x=rnd(-0.6,0.6), y=rnd(-0.6,0.6), z=rnd(-0.6,0.6);
        const d=Math.sqrt((x-nC.x)**2 + (y-nC.y)**2 + (z-nC.z)**2);
        if(d<nR) continue;
        nodes.push({id:`n${nodes.length}`,x,y,z,type:'sphere'});
      }

      /* instantiate visuals */
      nodes.forEach(n=>{
        if(n.type==='star'){
          cell.insertAdjacentHTML('beforeend',
            `<a-entity id="${n.id}"
                      text="value: ★; color: #ffff00; align: center; anchor: center; baseline: center; side: double; shader: flat; width: 1.5"
                      position="${n.x} ${n.y} ${n.z}"></a-entity>`);
        }else{
          cell.insertAdjacentHTML('beforeend',
            `<a-sphere id="${n.id}" radius="0.06" color="#888" position="${n.x} ${n.y} ${n.z}"></a-sphere>`);
        }
        n.el=document.getElementById(n.id);
      });

      /* connect each node to its three nearest neighbours (undirected) */
      nodes.forEach((n,i)=>{
        const dists=nodes.map((m,j)=>({j,dist:Math.hypot(n.x-m.x,n.y-m.y,n.z-m.z)}))
                         .sort((a,b)=>a.dist-b.dist);
        let added=0;
        for(let k=1;k<dists.length&&added<3;k++){
          const j=dists[k].j;if(j<i)continue; // avoid duplicate
          const id=`e${edges.length}`;
          const s=`${n.x} ${n.y} ${n.z}`;
          const e=`${nodes[j].x} ${nodes[j].y} ${nodes[j].z}`;
          cell.insertAdjacentHTML('beforeend',
            `<a-entity id="${id}" line="start:${s}; end:${e}; color:#666"></a-entity>`);
          edges.push({id,a:i,b:j,el:document.getElementById(id)});
          added++;
        }
      });
    }

    /******** Colour‑reset / propagation helpers ********/
    function setNodeColour(node, col){
      if(node.el.hasAttribute('text')){
        node.el.setAttribute('text',`color:${col}`);
      }else{
        node.el.setAttribute('color',col);
      }
    }
    function resetColours(defaultCol){
      nodes.forEach(n=>{
        const col = n.type==='star' ? '#ffff00' : defaultCol;
        setNodeColour(n,col);
      });
      edges.forEach(e=>e.el.setAttribute('line',`color:${defaultCol}`));
    }

    function propagate(){
      timers.forEach(clearTimeout); timers=[];
      resetColours('#888');
      const visited=new Set([0]), waves=[[0]];
      while(waves[waves.length-1].length){
        const nxt=[];
        waves[waves.length-1].forEach(i=>{
          edges.forEach(e=>{
            const nb=e.a===i?e.b:e.b===i?e.a:null;
            if(nb!==null && !visited.has(nb)){visited.add(nb);nxt.push(nb);}  
          });
        });
        if(nxt.length) waves.push(nxt); else break;
      }
      waves.forEach((wave,w)=>{
        timers.push(setTimeout(()=>{
          wave.forEach(i=>setNodeColour(nodes[i],'#ff0000'));
          edges.forEach(e=>{
            const ca=nodes[e.a].el.hasAttribute('text') ? nodes[e.a].el.getAttribute('text').color : nodes[e.a].el.getAttribute('color');
            const cb=nodes[e.b].el.hasAttribute('text') ? nodes[e.b].el.getAttribute('text').color : nodes[e.b].el.getAttribute('color');
            if(ca==="#ff0000" && cb==="#ff0000")
              e.el.setAttribute('line','color:#ff0000');
          });
        },w*PROP_INTERVAL));
      });
    }
    function resetNetwork(){
      timers.forEach(clearTimeout);timers=[];
      resetColours('#666');
    }

    /******** Lifecycle ********/
    scene.addEventListener('loaded',()=>{
      loader.style.display='none';
      addOrganelles();
      addCytoskeleton();
      buildNetwork();
    });
    marker.addEventListener('markerFound',()=>{
      cell.setAttribute('visible',true);
      statusTxt.textContent='Success';
      startBtn.style.display='block';
    });
    marker.addEventListener('markerLost',()=>{
      cell.setAttribute('visible',false);
      statusTxt.textContent='Searching…';
      startBtn.style.display='none';
      resetNetwork();
    });

    startBtn.addEventListener('click', () => {
      propagate();
      startBtn.style.display = 'none';
    });

    resetBtn.addEventListener('click', () => {
      resetNetwork();
      propagate();
    });
  </script>
</body>
</html>
