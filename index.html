<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Cubic cell – zoomable 50‑node network</title>

  <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/3.4.7/aframe/build/aframe-ar.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-meshline@1.2.0/dist/aframe-meshline.min.js"></script>

  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{margin:0;overflow:hidden;font-family:monospace}
    #status{position:fixed;top:10px;left:10px;font-size:24px;color:#fff;z-index:1000}
    #resetBtn{position:fixed;bottom:12px;left:12px;padding:6px 12px;font:16px monospace;
              background:#222;color:#fff;border:1px solid #888;border-radius:4px;opacity:0.85;
              z-index:1000}
    #loader{position:fixed;inset:0;display:flex;flex-direction:column;justify-content:center;
            align-items:center;background:#000}
    .spinner{width:48px;height:48px;border:6px solid #fff;border-top-color:transparent;
             border-radius:50%;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
  </style>
</head>

<body>
  <div id="loader"><div class="spinner"></div><p style="color:#fff;margin-top:12px">Loading camera…</p></div>
  <div id="status">Searching…</div>
  <button id="resetBtn">Reset signal</button>

  <a-scene embedded arjs="sourceType: webcam; debugUIEnabled:false;">
    <a-marker id="hiroMarker" preset="hiro" emitevents="true">
      <a-entity id="cell"
                visible="false"
                drag-rotate
                zoom-controls>
      </a-entity>
    </a-marker>
    <a-entity camera></a-entity>
  </a-scene>

  <!-- drag‑rotate component -->
  <script>
    AFRAME.registerComponent('drag-rotate',{schema:{speed:{default:1}},init(){
      const cvs=this.el.sceneEl.canvas;let dragging=false,px=0,py=0;
      const start=e=>{dragging=true;px=e.clientX;py=e.clientY};
      const move=(x,y,f=1)=>{ if(!dragging) return;
        const rot=this.el.getAttribute('rotation');
        this.el.setAttribute('rotation',{
          x:rot.x + (y - py) * f * this.data.speed,
          y:rot.y + (x - px) * f * this.data.speed,
          z:rot.z
        });
        px=x; py=y;
      };
      cvs.addEventListener('mousedown',  e=>start(e));
      window.addEventListener('mousemove',e=>move(e.clientX,e.clientY));
      window.addEventListener('mouseup',  ()=>dragging=false);
      cvs.addEventListener('touchstart', e=>start(e.touches[0]),{passive:false});
      window.addEventListener('touchmove',e=>{ if(dragging){ e.preventDefault(); move(e.touches[0].clientX,e.touches[0].clientY,0.5) }},{passive:false});
      window.addEventListener('touchend', ()=>dragging=false);
    }});
  </script>

  <!-- zoom‑controls component -->
  <script>
    AFRAME.registerComponent('zoom-controls', {
      schema: {
        min: { type: 'number', default: 0.3 },
        max: { type: 'number', default: 4 },
        step: { type: 'number', default: 0.1 }
      },
      init() {
        this.scale = 1;
        this.el.setAttribute('scale', { x:1, y:1, z:1 });
        this.handleWheel = this.handleWheel.bind(this);
        this.onTouchStart = this.onTouchStart.bind(this);
        this.onTouchMove  = this.onTouchMove.bind(this);
        this.el.sceneEl.canvas.addEventListener('wheel', this.handleWheel);
        this.el.sceneEl.canvas.addEventListener('touchstart', this.onTouchStart,{passive:false});
        this.el.sceneEl.canvas.addEventListener('touchmove',  this.onTouchMove,{passive:false});
      },
      remove() {
        this.el.sceneEl.canvas.removeEventListener('wheel', this.handleWheel);
        this.el.sceneEl.canvas.removeEventListener('touchstart', this.onTouchStart);
        this.el.sceneEl.canvas.removeEventListener('touchmove',  this.onTouchMove);
      },
      handleWheel(evt) {
        evt.preventDefault();
        const delta = evt.deltaY < 0 ? this.data.step : -this.data.step;
        this.updateScale(this.scale + delta);
      },
      onTouchStart(evt) {
        if (evt.touches.length === 2) {
          this.startDist = this.getDist(evt.touches);
          this.startScale = this.scale;
        }
      },
      onTouchMove(evt) {
        if (evt.touches.length === 2) {
          evt.preventDefault();
          const newDist = this.getDist(evt.touches);
          const factor = newDist / this.startDist;
          this.updateScale(this.startScale * factor);
        }
      },
      getDist(touches) {
        const a = touches[0], b = touches[1];
        const dx = a.clientX - b.clientX, dy = a.clientY - b.clientY;
        return Math.hypot(dx, dy);
      },
      updateScale(newScale) {
        this.scale = Math.min(this.data.max, Math.max(this.data.min, newScale));
        this.el.setAttribute('scale', { x:this.scale, y:this.scale, z:this.scale });
      }
    });
  </script>

  <script>
    /* core logic reused from before */
    const scene=document.querySelector('a-scene');
    const marker=document.getElementById('hiroMarker');
    const cell=document.getElementById('cell');
    const status=document.getElementById('status');
    const loader=document.getElementById('loader');
    const resetBtn=document.getElementById('resetBtn');

    const N_NODES = 50, PROP_INTERVAL = 1200, LINE_W = 16;
    const nodes = [], edges = [], timers = [];

    /* ...organelles, buildNetwork, propagate, resetNetwork functions go here... */
    /* copy them exactly from your working script above */

    // For brevity, assume you paste in your existing 
    // addOrganelles(), buildNetwork(), propagate(), resetNetwork() here.

    scene.addEventListener('loaded',()=>{
      loader.style.display='none';
      addOrganelles();
      buildNetwork();
    });

    marker.addEventListener('markerFound',()=>{
      cell.setAttribute('visible',true);
      status.textContent='Success';
      propagate();
    });
    marker.addEventListener('markerLost',()=>{
      cell.setAttribute('visible',false);
      status.textContent='Searching…';
      resetNetwork();
    });

    resetBtn.addEventListener('click',()=>{
      resetNetwork();
      propagate(); // restart immediately
    });
  </script>
</body>
</html>
