<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Cubic cell – DNA helix & gene nodes</title>

  <!-- A‑Frame & AR.js -->
  <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/3.4.7/aframe/build/aframe-ar.js"></script>

  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>/* —— same button / loader styling as previous answer —— */</style>
</head>

<body>
  <!-- UI buttons (unchanged) -->
  <div id="loader"><div class="spinner"></div><p style="color:#fff;margin-top:12px">Loading camera…</p></div>
  <div id="status">Searching…</div>
  <button id="resetBtn"   class="btn">Reset</button>
  <button id="pathBtn"    class="btn">Path&nbsp;propagation</button>
  <button id="diffuseBtn" class="btn">Full&nbsp;diffusion</button>
  <button id="secreteBtn" class="btn">Secrete&nbsp;protein</button>
  <button id="zoomInBtn"  class="btn">＋</button>
  <button id="zoomOutBtn" class="btn">－</button>

  <a-scene embedded arjs="sourceType: webcam; debugUIEnabled:false;">
    <a-marker id="hiroMarker" preset="hiro" emitevents="true">
      <a-entity id="cell" visible="false" drag-rotate scale="4 4 4"></a-entity>
      <a-cylinder id="bacterium" radius="0.12" height="0.36"
                  color="#35c94a" position="0 2.2 0" rotation="90 0 0"></a-cylinder>
    </a-marker>
    <a-entity camera></a-entity>
  </a-scene>

  <!-- drag‑rotate component (unchanged) -->
  <script>/* … same drag‑rotate JS … */</script>

  <script>
    /* ===== constants & handles ===== */
    const cell=document.getElementById('cell'),
          bacterium=document.getElementById('bacterium'),
          statusTxt=document.getElementById('status'),
          loader=document.getElementById('loader'),
          marker=document.getElementById('hiroMarker'),
          pathBtn=document.getElementById('pathBtn'),
          diffuseBtn=document.getElementById('diffuseBtn'),
          secreteBtn=document.getElementById('secreteBtn'),
          resetBtn=document.getElementById('resetBtn'),
          zoomInBtn=document.getElementById('zoomInBtn'),
          zoomOutBtn=document.getElementById('zoomOutBtn');

    const N_NODES=150, N_ENDPOINTS=4, PROP_INTERVAL=900,
          NETWORK_RADIUS=0.006, CUBE_RADIUS=0.02,
          DNA_RADIUS=0.12, DNA_HEIGHT=0.5, DNA_TURNS=3,
          SCALE_MIN=1, SCALE_MAX=10;
    let currentScale=4, secretedCount=0;

    const nodes=[],edges=[],endpointIdx=[],timers=[];

    /* ===== cylinders helper ===== */
    function addCylinder(a,b,r,col,parent){
      const mid=a.clone().add(b).multiplyScalar(0.5);
      const len=a.distanceTo(b);
      const id=`cyl-${Math.random().toString(36).slice(2)}`;
      parent.insertAdjacentHTML('beforeend',
        `<a-cylinder id="${id}" position="${mid.x} ${mid.y} ${mid.z}"
                     radius="${r}" height="${len}" color="${col}"
                     material="opacity:0.9;shader:flat"></a-cylinder>`);
      document.getElementById(id).object3D.quaternion.setFromUnitVectors(
        new THREE.Vector3(0,1,0), b.clone().sub(a).normalize());
      return id;
    }

    /* ===== cube frame & yellow nucleus ===== */
    function drawFrameAndNucleus(){
      const h=0.8, edges=[[[-h,-h,-h],[-h, h,-h]], [[ h,-h,-h],[ h, h,-h]],
                          [[-h,-h, h],[-h, h, h]], [[ h,-h, h],[ h, h, h]],
                          [[-h, h,-h],[ h, h,-h]], [[ h, h,-h],[ h, h, h]],
                          [[ h, h, h],[-h, h, h]], [[-h, h, h],[-h, h,-h]],
                          [[-h,-h,-h],[ h,-h,-h]], [[ h,-h,-h],[ h,-h, h]],
                          [[ h,-h, h],[-h,-h, h]], [[-h,-h, h],[-h,-h,-h]]];
      edges.forEach(p=>addCylinder(
        new THREE.Vector3(...p[0]),new THREE.Vector3(...p[1]),CUBE_RADIUS,'#000',cell));
      const nY=-0.55;
      cell.insertAdjacentHTML('beforeend',
        `<a-sphere radius="0.25" position="0 ${nY} 0"
                   material="color:#ffff00;opacity:0.45;transparent:true;side:double"></a-sphere>
         <a-sphere radius="0.28" position="0 ${nY} 0"
                   material="color:#ffffaa;opacity:0.15;transparent:true;side:double"></a-sphere>`);
    }

    /* ===== DNA double‑helix ===== */
    function addDNA(){
      const nC=new THREE.Vector3(0,-0.55,0);
      const total=DNA_TURNS*2*Math.PI, step=0.3;
      let lastA=null, lastB=null;
      for(let t=0;t<=total;t+=step){
        const y=nC.y-DNA_HEIGHT/2 + (t/total)*DNA_HEIGHT;
        const a=new THREE.Vector3(DNA_RADIUS*Math.cos(t), y, DNA_RADIUS*Math.sin(t)).add(nC);
        const b=new THREE.Vector3(DNA_RADIUS*Math.cos(t+Math.PI), y, DNA_RADIUS*Math.sin(t+Math.PI)).add(nC);
        if(lastA) addCylinder(lastA,a,0.005,'#ff0000',cell);
        if(lastB) addCylinder(lastB,b,0.005,'#0000ff',cell);
        /* rung every ~0.6 rad */
        if(Math.abs((t/step)%2)<1e-3) addCylinder(a,b,0.003,'#888',cell);
        lastA=a; lastB=b;
      }
      return nC;
    }

    /* ===== build whole scene graph (nodes + DNA) ===== */
    const rnd=(a,b)=>Math.random()*(b-a)+a;
    function buildNetwork(){
      cell.innerHTML='';           // wipe previous
      nodes.length=edges.length=endpointIdx.length=0;
      drawFrameAndNucleus();
      const nC=addDNA();           // returns centre vector of nucleus

      /* blue start node just under membrane */
      nodes.push({id:'n0',x:0,y:0.9,z:0,type:'star'});

      /* gene nodes on helix axis */
      for(let g=1;g<=N_ENDPOINTS;g++){
        const frac=g/(N_ENDPOINTS+1);                 // 0..1
        const y=nC.y-DNA_HEIGHT/2 + frac*DNA_HEIGHT;  // along helix core
        nodes.push({id:`n${nodes.length}`,x:0,y,z:0,type:'endpoint'});
        endpointIdx.push(nodes.length-1);
      }

      /* remaining random cytoplasmic nodes */
      const nucleusR=0.30;
      while(nodes.length<N_NODES){
        const x=rnd(-0.6,0.6),y=rnd(-0.6,0.6),z=rnd(-0.6,0.6);
        if(Math.hypot(x-nC.x,y-nC.y,z-nC.z)<nucleusR) continue;
        nodes.push({id:`n${nodes.length}`,x,y,z,type:'sphere'});
      }

      /* visuals for nodes */
      nodes.forEach(n=>{
        const r=n.type==='sphere'?0.04:0.06;
        const col=n.type==='star'?'#0000ff':n.type==='endpoint'?'#00ff00':'#888';
        cell.insertAdjacentHTML('beforeend',
          `<a-sphere id="${n.id}" radius="${r}" color="${col}"
                     position="${n.x} ${n.y} ${n.z}"></a-sphere>`);
        n.el=document.getElementById(n.id);
      });

      /* network edges (3 nearest) */
      nodes.forEach((n,i)=>{
        const dists=nodes.map((m,j)=>({j,dist:Math.hypot(n.x-m.x,n.y-m.y,n.z-m.z)}))
                         .sort((a,b)=>a.dist-b.dist);
        let added=0;
        for(let k=1;k<dists.length&&added<3;k++){
          const j=dists[k].j;if(j<i)continue;
          const id=addCylinder(
            new THREE.Vector3(n.x,n.y,n.z),
            new THREE.Vector3(nodes[j].x,nodes[j].y,nodes[j].z),
            NETWORK_RADIUS,'#666',cell);
          edges.push({a:i,b:j,el:document.getElementById(id)});
          added++;
        }
      });
    }

    /* ===== colouring, propagation, secretion (exactly as previous version) ===== */
    /* … setNodeColour, resetColours, propagatePaths, propagateDiffuse, secreteProtein … */
    /* (They remain unchanged and work because only node positions changed.) */

    /* ===== lifecycle ===== */
    document.querySelector('a-scene').addEventListener('loaded',()=>{
      loader.style.display='none';
      buildNetwork();
    });
    marker.addEventListener('markerFound',()=>{
      cell.setAttribute('visible',true);
      statusTxt.textContent='Success';
      pathBtn.style.display=diffuseBtn.style.display=secreteBtn.style.display='block';
    });
    marker.addEventListener('markerLost',()=>{
      cell.setAttribute('visible',false);
      statusTxt.textContent='Searching…';
      pathBtn.style.display=diffuseBtn.style.display=secreteBtn.style.display='none';
      resetNetwork();
    });

    /* button wiring */
    pathBtn.onclick    =()=>propagatePaths();
    diffuseBtn.onclick =()=>propagateDiffuse();
    secreteBtn.onclick =()=>secreteProtein();
    resetBtn.onclick   =()=>{buildNetwork();};
  </script>
</body>
</html>
