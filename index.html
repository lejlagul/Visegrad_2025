<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Network Model – Drag & Orbit</title>

  <!-- A-Frame core -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <!-- Orbit-controls component -->
  <script src="https://cdn.jsdelivr.net/npm/aframe-orbit-controls-component@1.3.0/dist/aframe-orbit-controls.min.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin: 0; overflow: hidden; font-family: monospace; }
    .btn {
      position: fixed; padding: 6px 12px; font:16px monospace;
      background:#222; color:#fff; border:1px solid #888; border-radius:4px;
      opacity:.85; cursor:pointer; z-index:1000;
    }
    .btn:disabled { background:#555; color:#999; cursor:not-allowed; }
    #resetBtn          { bottom:12px; left:12px; }
    #secretePathBtn    { bottom:12px; right:12px; }
    #secreteDiffuseBtn { bottom:56px; right:12px; }
    #zoomInBtn         { bottom:12px; left:calc(50% - 34px); }
    #zoomOutBtn        { bottom:12px; left:calc(50% + 2px); }
  </style>

  <!-- Drag‑rotate component (for spinning the cube itself) -->
  <script>
    AFRAME.registerComponent('drag-rotate', {
      schema: { speed: { default: 1 } },
      init: function () {
        this.dragging = false;
        let lastX, lastY;
        const el = this.el;
        const canvas = this.el.sceneEl.canvas;

        const startDrag = e => {
          this.dragging = true;
          lastX = e.clientX;
          lastY = e.clientY;
        };
        const endDrag = () => { this.dragging = false; };
        const doDrag = e => {
          if (!this.dragging) return;
          const dx = e.clientX - lastX;
          const dy = e.clientY - lastY;
          const rot = el.getAttribute('rotation');
          el.setAttribute('rotation', {
            x: rot.x + dy * this.data.speed,
            y: rot.y + dx * this.data.speed,
            z: rot.z
          });
          lastX = e.clientX; lastY = e.clientY;
        };

        canvas.addEventListener('mousedown', startDrag);
        window.addEventListener('mouseup', endDrag);
        window.addEventListener('mousemove', doDrag);

        // touch support
        canvas.addEventListener('touchstart', e => { startDrag(e.touches[0]); }, { passive: false });
        canvas.addEventListener('touchmove', e => {
          e.preventDefault();
          doDrag(e.touches[0]);
        }, { passive: false });
        canvas.addEventListener('touchend', endDrag);
      }
    });
  </script>
</head>
<body>
  <!-- Buttons -->
  <button id="resetBtn"          class="btn">Reset</button>
  <button id="secretePathBtn"    class="btn">Secrete & Path</button>
  <button id="secreteDiffuseBtn" class="btn">Secrete & Diffuse</button>
  <button id="zoomInBtn"         class="btn">＋</button>
  <button id="zoomOutBtn"        class="btn">－</button>

  <a-scene background="color: #000">
    <!-- Camera with orbit-controls -->
    <a-entity
      id="cam"
      camera
      position="0 0 5"
      orbit-controls="
        target: 0 0 0;
        enableDamping: true;
        dampingFactor: 0.125;
        rotateSpeed: 0.3;
        zoomSpeed: 1.2;
        minDistance: 2;
        maxDistance: 20;
        enableZoom: true;
        enablePan: false;">
    </a-entity>

    <!-- Lights -->
    <a-entity light="type: ambient; color: #555"></a-entity>
    <a-entity light="type: directional; intensity: 0.6" position="1 1 1"></a-entity>

    <!-- Your cube model: drag-rotate lets you spin it directly -->
    <a-entity
      id="cell"
      visible="false"
      scale="2 2 2"
      drag-rotate
      gltf-model="url(path/to/your_cube_model.glb)">
    </a-entity>
  </a-scene>

  <script>
    // ======== Handles & Constants ========
    const cell              = document.getElementById('cell'),
          cam               = document.getElementById('cam'),
          resetBtn          = document.getElementById('resetBtn'),
          secretePathBtn    = document.getElementById('secretePathBtn'),
          secreteDiffuseBtn = document.getElementById('secreteDiffuseBtn'),
          zoomInBtn         = document.getElementById('zoomInBtn'),
          zoomOutBtn        = document.getElementById('zoomOutBtn');

    const N_NODES        = 150,
          N_ENDPOINTS    = 4,
          PROP_INTERVAL  = 900,
          NETWORK_RADIUS = 0.006;

    let secretedCount = 0,
        nodes = [], edges = [], endpointIdx = [], timers = [];

    // ======== Zoom Buttons (adjust camera distance) ========
    function zoomCamera(factor) {
      const pos = cam.getAttribute('position');
      cam.setAttribute('position', {
        x: pos.x,
        y: pos.y,
        z: THREE.MathUtils.clamp(pos.z * factor, 2, 20)
      });
    }
    zoomInBtn.onclick  = () => zoomCamera(0.8);
    zoomOutBtn.onclick = () => zoomCamera(1.2);

    // ======== Network generation ========
    const rnd = (a,b) => Math.random()*(b-a)+a;
    function buildNetwork() {
      // clear old decorations (keep the glTF mesh)
      Array.from(cell.children)
        .filter(el => !el.hasAttribute('gltf-model'))
        .forEach(el => el.remove());
      nodes = []; edges = []; endpointIdx = []; timers = [];

      // star node at top
      nodes.push({id:'n0', x:0, y:1, z:0, type:'star'});
      // endpoints around inside
      for(let i=0;i<N_ENDPOINTS;i++){
        const angle = (i/(N_ENDPOINTS-1))*Math.PI*2;
        const x = 0.5*Math.cos(angle),
              y = -0.5 + (i/(N_ENDPOINTS-1))*1.0,
              z = 0.5*Math.sin(angle);
        endpointIdx.push(nodes.length);
        nodes.push({id:`n${nodes.length}`, x,y,z, type:'endpoint'});
      }
      // random nodes
      while(nodes.length < N_NODES){
        const x=rnd(-0.8,0.8), y=rnd(-0.8,0.8), z=rnd(-0.8,0.8);
        if(Math.hypot(x,y,z) < 0.2) continue;
        nodes.push({id:`n${nodes.length}`, x,y,z, type:'sphere'});
      }

      // spheres
      nodes.forEach(n=>{
        const r = n.type==='sphere'?0.04:0.06;
        const c = n.type==='star'   ? '#0000ff'
                : n.type==='endpoint'? '#00ff00'
                                      : '#BBBBBB';
        const sph = document.createElement('a-sphere');
        sph.setAttribute('id', n.id);
        sph.setAttribute('radius', r);
        sph.setAttribute('color', c);
        sph.setAttribute('position', `${n.x} ${n.y} ${n.z}`);
        cell.appendChild(sph);
        n.el = sph;
      });

      // cylinders
      nodes.forEach((n,i)=>{
        const dists = nodes.map((m,j)=>({j, d:Math.hypot(n.x-m.x,n.y-m.y,n.z-m.z)}))
                           .sort((a,b)=>a.d-b.d);
        let added=0;
        for(let k=1;k<dists.length && added<3;k++){
          const j = dists[k].j; if(j<i) continue;
          const aVec = new THREE.Vector3(n.x,n.y,n.z);
          const bVec = new THREE.Vector3(nodes[j].x,nodes[j].y,nodes[j].z);
          const id   = `cyl-${Math.random().toString(36).slice(2)}`;
          cell.insertAdjacentHTML('beforeend',
            `<a-cylinder id="${id}"
                         radius="${NETWORK_RADIUS}"
                         height="${aVec.distanceTo(bVec)}"
                         color="#AAAAAA"
                         position="${aVec.clone().add(bVec).multiplyScalar(0.5).toArray().join(' ')}"
                         material="opacity:0.7;shader:flat"></a-cylinder>`);
          const cyl = document.getElementById(id);
          cyl.object3D.quaternion.setFromUnitVectors(
            new THREE.Vector3(0,1,0),
            bVec.clone().sub(aVec).normalize()
          );
          edges.push({a:i,b:j,el:cyl});
          added++;
        }
      });
    }

    function resetColours(base='#AAAAAA'){
      nodes.forEach(n=>{
        let c = base;
        if(n.type==='star')       c='#0000ff';
        else if(n.type==='endpoint') c='#00ff00';
        n.el.setAttribute('color', c);
      });
      edges.forEach(e=>e.el.setAttribute('color', base));
    }
    function resetNetwork(){
      timers.forEach(clearTimeout);
      timers.length=0;
      resetColours();
      secretePathBtn.disabled = secreteDiffuseBtn.disabled = false;
      document.querySelectorAll('[id^="prot-"]').forEach(p=>p.remove());
    }

    // propagation & secretion (same logic as before)...
    function propagatePaths(){ /* …copy your BFS code here… */ }
    function propagateDiffuse(){ /* …copy your diffusion code here… */ }
    function secreteProtein(){ /* …copy your secretion code here… */ }

    // show and build on load
    document.querySelector('a-scene').addEventListener('loaded',()=>{
      cell.setAttribute('visible', true);
      buildNetwork();
    });

    resetBtn.onclick          = resetNetwork;
    secretePathBtn.onclick    = ()=>{
      secreteProtein();
      secretePathBtn.disabled = secreteDiffuseBtn.disabled = true;
      timers.push(setTimeout(propagatePaths,2500));
    };
    secreteDiffuseBtn.onclick = ()=>{
      secreteProtein();
      secretePathBtn.disabled = secreteDiffuseBtn.disabled = true;
      timers.push(setTimeout(propagateDiffuse,2500));
    };
  </script>
</body>
</html>
