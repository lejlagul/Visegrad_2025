<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Network Model with Cube GLB</title>

  <!-- A-Frame core -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <!-- Orbit controls component -->
  <script src="https://cdn.jsdelivr.net/npm/aframe-orbit-controls-component@1.3.0/dist/aframe-orbit-controls.min.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin: 0; overflow: hidden; font-family: monospace; }
    .btn {
      position: fixed;
      padding: 6px 12px;
      font: 16px monospace;
      background: #222;
      color: #fff;
      border: 1px solid #888;
      border-radius: 4px;
      opacity: 0.85;
      cursor: pointer;
      z-index: 1000;
    }
    .btn:disabled { background: #555; color: #999; cursor: not-allowed; }
    #resetBtn          { bottom: 12px; left: 12px; }
    #secretePathBtn    { bottom: 12px; right: 12px; }
    #secreteDiffuseBtn { bottom: 56px; right: 12px; }
    #zoomInBtn         { bottom: 12px; left: calc(50% - 34px); }
    #zoomOutBtn        { bottom: 12px; left: calc(50% + 2px); }
  </style>
</head>
<body>
  <!-- Controls -->
  <button id="resetBtn"          class="btn">Reset</button>
  <button id="secretePathBtn"    class="btn">Secrete & Path</button>
  <button id="secreteDiffuseBtn" class="btn">Secrete & Diffuse</button>
  <button id="zoomInBtn"         class="btn">＋</button>
  <button id="zoomOutBtn"        class="btn">－</button>

  <a-scene background="color: #000">
    <!-- Camera + Orbit Controls -->
    <a-entity
      id="cam"
      camera
      position="0 0 5"
      orbit-controls="
        target: 0 0 0;
        enableDamping: true;
        dampingFactor: 0.125;
        rotateSpeed: 0.3;
        zoomSpeed: 1.2;
        minDistance: 2;
        maxDistance: 20;">
    </a-entity>

    <!-- Lighting -->
    <a-entity light="type: ambient; color: #555"></a-entity>
    <a-entity light="type: directional; intensity: 0.6" position="1 1 1"></a-entity>

    <!-- Your cube model + network container -->
    <a-entity
      id="cell"
      visible="false"
      scale="2 2 2"
      gltf-model="url(path/to/your_cube_model.glb)">
    </a-entity>
  </a-scene>

  <script>
    // === Handles & Constants ===
    const cell              = document.getElementById('cell'),
          cam               = document.getElementById('cam'),
          resetBtn          = document.getElementById('resetBtn'),
          secretePathBtn    = document.getElementById('secretePathBtn'),
          secreteDiffuseBtn = document.getElementById('secreteDiffuseBtn'),
          zoomInBtn         = document.getElementById('zoomInBtn'),
          zoomOutBtn        = document.getElementById('zoomOutBtn');

    const N_NODES        = 150,
          N_ENDPOINTS    = 4,
          PROP_INTERVAL  = 900,
          NETWORK_RADIUS = 0.006;

    let currentScale  = 2,
        secretedCount = 0;

    const nodes = [], edges = [], endpointIdx = [], timers = [];

    // === Zoom Buttons (adjust camera distance) ===
    function zoomCamera(factor) {
      const pos = cam.getAttribute('position');
      // multiply z-distance
      cam.setAttribute('position', {
        x: pos.x,
        y: pos.y,
        z: THREE.MathUtils.clamp(pos.z * factor, 2, 20)
      });
    }
    zoomInBtn.onclick  = () => zoomCamera(0.8);
    zoomOutBtn.onclick = () => zoomCamera(1.2);

    // === Network generation & helpers ===
    const rnd = (a,b) => Math.random()*(b-a)+a;
    function buildNetwork() {
      // clear any old children (but keep the model)
      Array.from(cell.children)
        .filter(el => !el.hasAttribute('gltf-model'))
        .forEach(el => el.remove());
      nodes.length = edges.length = endpointIdx.length = 0;

      // star node at top of cube
      nodes.push({id:'n0', x:0, y:1, z:0, type:'star'});
      // endpoints around center
      for(let i=0;i<N_ENDPOINTS;i++){
        const angle = (i/(N_ENDPOINTS-1))*Math.PI*2;
        const x = 0.5 * Math.cos(angle),
              y = -0.5 + (i/(N_ENDPOINTS-1)) * 1.0,
              z = 0.5 * Math.sin(angle);
        endpointIdx.push(nodes.length);
        nodes.push({id:`n${nodes.length}`, x,y,z, type:'endpoint'});
      }
      // random nodes inside
      while(nodes.length < N_NODES){
        const x=rnd(-0.8,0.8), y=rnd(-0.8,0.8), z=rnd(-0.8,0.8);
        if(Math.hypot(x,y,z) < 0.2) continue;
        nodes.push({id:`n${nodes.length}`, x,y,z, type:'sphere'});
      }
      // place spheres
      nodes.forEach(n=>{
        const r = n.type==='sphere'?0.04:0.06;
        const c = n.type==='star'   ? '#0000ff'
                : n.type==='endpoint'? '#00ff00'
                                      : '#BBBBBB';
        const sph = document.createElement('a-sphere');
        sph.setAttribute('id', n.id);
        sph.setAttribute('radius', r);
        sph.setAttribute('color', c);
        sph.setAttribute('position', `${n.x} ${n.y} ${n.z}`);
        cell.appendChild(sph);
        n.el = sph;
      });
      // connect neighbours
      const THREEvec = THREE.Vector3;
      nodes.forEach((n,i)=>{
        const dists = nodes.map((m,j)=>({j, d:Math.hypot(n.x-m.x,n.y-m.y,n.z-m.z)}))
                           .sort((a,b)=>a.d-b.d);
        let added=0;
        for(let k=1;k<dists.length&&added<3;k++){
          const j=dists[k].j; if(j<i) continue;
          const aVec = new THREEvec(n.x,n.y,n.z);
          const bVec = new THREEvec(nodes[j].x,nodes[j].y,nodes[j].z);
          const cylId = `cyl-${Math.random().toString(36).slice(2)}`;
          cell.insertAdjacentHTML('beforeend',
            `<a-cylinder id="${cylId}"
                         radius="${NETWORK_RADIUS}"
                         height="${aVec.distanceTo(bVec)}"
                         color="#AAAAAA"
                         position="${aVec.clone().add(bVec).multiplyScalar(0.5).toArray().join(' ')}"
                         material="opacity:0.7;shader:flat"></a-cylinder>`);
          const cyl = document.getElementById(cylId);
          cyl.object3D.quaternion.setFromUnitVectors(
            new THREE.Vector3(0,1,0),
            bVec.clone().sub(aVec).normalize()
          );
          edges.push({a:i, b:j, el:cyl});
          added++;
        }
      });
    }

    function resetColours(base='#AAAAAA'){
      nodes.forEach(n=>{
        let c = base;
        if(n.type==='star')      c='#0000ff';
        else if(n.type==='endpoint') c='#00ff00';
        n.el.setAttribute('color', c);
      });
      edges.forEach(e=>e.el.setAttribute('color', base));
    }
    function resetNetwork(){
      timers.forEach(clearTimeout);
      timers.length = 0;
      resetColours();
      secretePathBtn.disabled = secreteDiffuseBtn.disabled = false;
      document.querySelectorAll('[id^="prot-"]').forEach(p=>p.remove());
    }

    // === Propagation & Secretion ===
    function propagatePaths(){
      resetNetwork();
      const adj = Array(nodes.length).fill().map(()=>[]);
      const edgeMap = new Map();
      edges.forEach((e,i)=>{
        adj[e.a].push(e.b); adj[e.b].push(e.a);
        edgeMap.set(`${Math.min(e.a,e.b)}-${Math.max(e.a,e.b)}`, i);
      });
      const prev = Array(nodes.length).fill(-1),
            dist = Array(nodes.length).fill(Infinity),
            q = [0];
      dist[0]=0; let found=0;
      while(q.length && found<endpointIdx.length){
        const u = q.shift();
        adj[u].forEach(v=>{
          if(dist[v]!==Infinity) return;
          dist[v] = dist[u]+1; prev[v]=u; q.push(v);
          if(endpointIdx.includes(v)) found++;
        });
      }
      const pathNodes = new Set([0]), pathEdges = new Set();
      endpointIdx.forEach(ep=>{
        for(let u=ep; u!==0 && u!==-1; u=prev[u]){
          pathNodes.add(u);
          const key=`${Math.min(u,prev[u])}-${Math.max(u,prev[u])}`;
          if(edgeMap.has(key)) pathEdges.add(edgeMap.get(key));
        }
      });
      const pathDist = {}, visit=[0];
      pathNodes.forEach(i=>pathDist[i]=Infinity);
      pathDist[0]=0;
      while(visit.length){
        const u=visit.shift();
        adj[u].forEach(v=>{
          if(!pathNodes.has(v)||pathDist[v]!==Infinity) return;
          const k=`${Math.min(u,v)}-${Math.max(u,v)}`;
          if(pathEdges.has(edgeMap.get(k))){
            pathDist[v]=pathDist[u]+1;
            visit.push(v);
          }
        });
      }
      const maxStep = Math.max(...Object.values(pathDist));
      for(let s=0; s<=maxStep; s++){
        timers.push(setTimeout(()=>{
          Object.entries(pathDist).forEach(([i,d])=>{
            if(d===s) nodes[i].el.setAttribute('color','#ff0000');
          });
          pathEdges.forEach(ei=>{
            const e = edges[ei];
            if(pathDist[e.a]<=s && pathDist[e.b]<=s)
              e.el.setAttribute('color','#ff0000');
          });
        }, s*PROP_INTERVAL));
      }
    }

    function propagateDiffuse(){
      resetNetwork();
      const visited=new Set([0]), waves=[[0]];
      while(waves[waves.length-1].length){
        const next=[];
        waves[waves.length-1].forEach(i=>{
          edges.forEach(e=>{
            const nb = e.a===i ? e.b : e.b===i ? e.a : null;
            if(nb!==null && !visited.has(nb)){
              visited.add(nb); next.push(nb);
            }
          });
        });
        if(next.length) waves.push(next);
        else break;
      }
      waves.forEach((wave,w)=>{
        timers.push(setTimeout(()=>{
          wave.forEach(i=>nodes[i].el.setAttribute('color','#ff0000'));
          edges.forEach(e=>{
            const ca=nodes[e.a].el.getAttribute('color'),
                  cb=nodes[e.b].el.getAttribute('color');
            if(ca==='#ff0000' && cb==='#ff0000') e.el.setAttribute('color','#ff0000');
          });
        }, w*PROP_INTERVAL));
      });
    }

    function secreteProtein(){
      const id = `prot-${secretedCount++}`;
      cell.insertAdjacentHTML('beforeend',
        `<a-sphere id="${id}" radius="0.04" color="#ff00ff"
                   position="1 1 0"
                   animation="property: position;
                              to: 0 -0.5 0;
                              dur: 2500;
                              easing: linear;
                              fill: forwards"></a-sphere>`);
    }

    // === Init & Event Wiring ===
    document.querySelector('a-scene').addEventListener('loaded', ()=>{
      cell.setAttribute('visible', true);
      buildNetwork();
    });
    resetBtn.onclick = resetNetwork;
    secretePathBtn.onclick = ()=>{
      secreteProtein();
      secretePathBtn.disabled = secreteDiffuseBtn.disabled = true;
      timers.push(setTimeout(propagatePaths, 2500));
    };
    secreteDiffuseBtn.onclick = ()=>{
      secreteProtein();
      secretePathBtn.disabled = secreteDiffuseBtn.disabled = true;
      timers.push(setTimeout(propagateDiffuse, 2500));
    };
  </script>
</body>
</html>
