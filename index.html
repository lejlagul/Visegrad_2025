<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Cube‑Network (orbit‑controls only)</title>

  <!-- A‑Frame core -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <!-- Orbit‑controls for rotate & zoom -->
  <script src="https://cdn.jsdelivr.net/npm/aframe-orbit-controls-component@1.3.0/dist/aframe-orbit-controls.min.js"></script>

  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin:0; overflow:hidden; font-family:monospace; }
    .btn {
      position: fixed;
      padding: 6px 12px;
      font: 16px monospace;
      background: #222;
      color: #fff;
      border: 1px solid #888;
      border-radius: 4px;
      opacity: .85;
      cursor: pointer;
      z-index: 1000;
    }
    .btn:disabled { background: #555; color: #999; cursor: not-allowed; }
    #resetBtn           { bottom: 12px; left: 12px; }
    #secretePathBtn     { bottom: 12px; right: 12px; }
    #secreteDiffuseBtn  { bottom: 56px; right: 12px; }
    #zoomInBtn          { bottom: 12px; left: calc(50% - 34px); }
    #zoomOutBtn         { bottom: 12px; left: calc(50% + 2px); }
  </style>
</head>
<body>
  <!-- UI buttons -->
  <button id="resetBtn"          class="btn">Reset</button>
  <button id="secretePathBtn"    class="btn">Secrete & Path</button>
  <button id="secreteDiffuseBtn" class="btn">Secrete & Diffuse</button>
  <button id="zoomInBtn"         class="btn">＋</button>
  <button id="zoomOutBtn"        class="btn">－</button>

  <a-scene background="color:#000">
    <!-- Camera: orbit-controls handles both rotate & zoom -->
    <a-entity id="cam"
              camera
              position="0 0 10"
              orbit-controls="target: 0 0 0;
                              enableRotate: true;
                              enableZoom: true;
                              dampingFactor: 0.1;
                              rotateSpeed: 0.3;
                              zoomSpeed: 1.2;
                              minDistance: 5;
                              maxDistance: 30;">
    </a-entity>

    <!-- lights -->
    <a-entity light="type: ambient; color: #555"></a-entity>
    <a-entity light="type: directional; intensity: 0.6" position="1 1 1"></a-entity>

    <!-- Cube GLB + network container -->
    <a-entity id="cell"
              gltf-model="url(path/to/your_cube_model.glb)"
              visible="false"
              scale="2 2 2">
    </a-entity>
  </a-scene>

  <script>
    /* ==== Handles & Constants ==== */
    const cell              = document.getElementById('cell');
    const cam               = document.getElementById('cam');
    const resetBtn          = document.getElementById('resetBtn');
    const secretePathBtn    = document.getElementById('secretePathBtn');
    const secreteDiffuseBtn = document.getElementById('secreteDiffuseBtn');
    const zoomInBtn         = document.getElementById('zoomInBtn');
    const zoomOutBtn        = document.getElementById('zoomOutBtn');

    const N_NODES       = 150,
          N_ENDPOINTS   = 4,
          PROP_INTERVAL = 900,
          NETWORK_RADIUS = 0.006;

    let secretedCount = 0;
    const nodes = [], edges = [], endpointIdx = [], timers = [];

    /* ==== Zoom-buttons (adjust camera z within min/max) ==== */
    function adjustCamera(dz) {
      const pos = cam.getAttribute('position');
      const zNew = THREE.MathUtils.clamp(pos.z + dz, 5, 30);
      cam.setAttribute('position', { x: pos.x, y: pos.y, z: zNew });
    }
    zoomInBtn.onclick  = () => adjustCamera(-1);
    zoomOutBtn.onclick = () => adjustCamera(+1);

    /* ==== Cylinder helper ==== */
    function addCylinder(aVec, bVec, radius, color, parent) {
      const mid = aVec.clone().add(bVec).multiplyScalar(0.5);
      const len = aVec.distanceTo(bVec);
      const id  = `cyl-${Math.random().toString(36).slice(2)}`;
      parent.insertAdjacentHTML('beforeend',
        `<a-cylinder id="${id}"
                     position="${mid.x} ${mid.y} ${mid.z}"
                     radius="${radius}"
                     height="${len}"
                     color="${color}"
                     material="opacity:0.7;shader:flat"></a-cylinder>`);
      document.getElementById(id).object3D.quaternion.setFromUnitVectors(
        new THREE.Vector3(0,1,0),
        bVec.clone().sub(aVec).normalize()
      );
      return id;
    }

    /* ==== Build the network inside the cube ==== */
    function buildNetwork() {
      // remove old spheres & cylinders
      Array.from(cell.children)
        .filter(el => !el.hasAttribute('gltf-model'))
        .forEach(el => el.remove());

      nodes.length = edges.length = endpointIdx.length = 0;

      // star node at top
      nodes.push({ id:'n0', x:0, y:1, z:0, type:'star' });

      // endpoints spiraling
      for (let i=0; i<N_ENDPOINTS; i++) {
        const t = i/(N_ENDPOINTS-1),
              ang = t * Math.PI*2;
        nodes.push({
          id: `n${nodes.length}`,
          x: 0.5*Math.cos(ang),
          y: -0.5 + t,
          z: 0.5*Math.sin(ang),
          type: 'endpoint'
        });
        endpointIdx.push(nodes.length-1);
      }

      // random sphere nodes
      while (nodes.length < N_NODES) {
        const x = (Math.random()*1.6 - 0.8),
              y = (Math.random()*1.6 - 0.8),
              z = (Math.random()*1.6 - 0.8);
        if (Math.hypot(x,y,z) < 0.25) continue;
        nodes.push({ id:`n${nodes.length}`, x, y, z, type:'sphere' });
      }

      // create spheres
      nodes.forEach(n => {
        const r = (n.type==='sphere'?0.04:0.06);
        const c = (n.type==='star'   ? '#0000ff'
                :  n.type==='endpoint'? '#00ff00'
                                      : '#BBBBBB');
        const sph = document.createElement('a-sphere');
        sph.setAttribute('id', n.id);
        sph.setAttribute('radius', r);
        sph.setAttribute('color', c);
        sph.setAttribute('position', `${n.x} ${n.y} ${n.z}`);
        cell.appendChild(sph);
        n.el = sph;
      });

      // connect nearest neighbours
      nodes.forEach((n,i) => {
        const dists = nodes.map((m,j) => ({
          j, dist: Math.hypot(n.x-m.x,n.y-m.y,n.z-m.z)
        })).sort((a,b) => a.dist - b.dist);

        let added = 0;
        for (let k=1; k<dists.length && added<3; k++) {
          const j = dists[k].j;
          if (j < i) continue;
          const aV = new THREE.Vector3(n.x,n.y,n.z);
          const bV = new THREE.Vector3(nodes[j].x,nodes[j].y,nodes[j].z);
          addCylinder(aV, bV, NETWORK_RADIUS, '#AAAAAA', cell);
          edges.push({ a:i, b:j, el: cell.lastElementChild });
          added++;
        }
      });
    }

    /* ==== Colour & Reset ==== */
    function setNodeColour(n,c){ n.el.setAttribute('color',c); }
    function resetColours(base='#AAAAAA'){
      nodes.forEach(n=>{
        let c=base;
        if(n.type==='star')      c='#0000ff';
        else if(n.type==='endpoint') c='#00ff00';
        setNodeColour(n,c);
      });
      edges.forEach(e=>e.el.setAttribute('color',base));
    }
    function resetNetwork(){
      timers.forEach(clearTimeout);
      timers.length = 0;
      resetColours();
      secretePathBtn.disabled = secreteDiffuseBtn.disabled = false;
      document.querySelectorAll('[id^="prot-"]').forEach(p=>p.remove());
    }

    /* ==== Propagation ==== */
    function propagatePaths(){
      resetNetwork();
      const adj=[]; for(let i=0;i<nodes.length;i++) adj[i]=[];
      const edgeMap=new Map();
      edges.forEach((e,i)=>{
        adj[e.a].push(e.b);
        adj[e.b].push(e.a);
        edgeMap.set(`${Math.min(e.a,e.b)}-${Math.max(e.a,e.b)}`,i);
      });

      const prev=Array(nodes.length).fill(-1),
            dist=Array(nodes.length).fill(Infinity),
            q=[0];
      dist[0]=0; let found=0;
      while(q.length && found<endpointIdx.length){
        const u=q.shift();
        adj[u].forEach(v=>{
          if(dist[v]!==Infinity) return;
          dist[v]=dist[u]+1;
          prev[v]=u;
          q.push(v);
          if(endpointIdx.includes(v)) found++;
        });
      }

      const pathNodes=new Set([0]), pathEdges=new Set();
      endpointIdx.forEach(ep=>{
        for(let u=ep;u!==0&&u!==-1;u=prev[u]){
          pathNodes.add(u);
          const key=`${Math.min(u,prev[u])}-${Math.max(u,prev[u])}`;
          if(edgeMap.has(key)) pathEdges.add(edgeMap.get(key));
        }
      });

      const pathDist={}, visit=[0];
      pathNodes.forEach(i=>pathDist[i]=Infinity);
      pathDist[0]=0;
      while(visit.length){
        const u=visit.shift();
        adj[u].forEach(v=>{
          if(!pathNodes.has(v) || pathDist[v]!==Infinity) return;
          const key=`${Math.min(u,v)}-${Math.max(u,v)}`;
          if(pathEdges.has(edgeMap.get(key))){
            pathDist[v]=pathDist[u]+1;
            visit.push(v);
          }
        });
      }

      const maxStep=Math.max(...Object.values(pathDist));
      for(let s=0;s<=maxStep;s++){
        timers.push(setTimeout(()=>{
          Object.entries(pathDist).forEach(([i,d])=>{
            if(d===s) setNodeColour(nodes[i],'#ff0000');
          });
          pathEdges.forEach(ei=>{
            const e=edges[ei];
            if(pathDist[e.a]<=s && pathDist[e.b]<=s)
              e.el.setAttribute('color','#ff0000');
          });
        }, s*PROP_INTERVAL));
      }
    }

    function propagateDiffuse(){
      resetNetwork();
      const visited=new Set([0]), waves=[[0]];
      while(waves[waves.length-1].length){
        const next=[];
        waves[waves.length-1].forEach(i=>{
          edges.forEach(e=>{
            const nb=e.a===i?e.b:e.b===i?e.a:null;
            if(nb!==null && !visited.has(nb)){
              visited.add(nb);
              next.push(nb);
            }
          });
        });
        if(next.length) waves.push(next);
        else break;
      }
      waves.forEach((wave,w)=>{
        timers.push(setTimeout(()=>{
          wave.forEach(i=>setNodeColour(nodes[i],'#ff0000'));
          edges.forEach(e=>{
            const ca=nodes[e.a].el.getAttribute('color'),
                  cb=nodes[e.b].el.getAttribute('color');
            if(ca==='#ff0000' && cb==='#ff0000')
              e.el.setAttribute('color','#ff0000');
          });
        }, w*PROP_INTERVAL));
      });
    }

    /* ==== Secretion ==== */
    function secreteProtein(){
      const id=`prot-${secretedCount++}`;
      cell.insertAdjacentHTML('beforeend',
        `<a-sphere id="${id}" radius="0.04" color="#ff00ff"
                   position="1 1 0"
                   animation="property: position;
                              to: 0 -0.5 0;
                              dur: 2500;
                              easing: linear;
                              fill: forwards"></a-sphere>`);
    }

    /* ==== Init & Event Wiring ==== */
    document.querySelector('a-scene').addEventListener('loaded', () => {
      cell.setAttribute('visible', true);
      buildNetwork();
    });
    resetBtn.onclick = resetNetwork;
    secretePathBtn.onclick = () => {
      secreteProtein();
      secretePathBtn.disabled = secreteDiffuseBtn.disabled = true;
      timers.push(setTimeout(propagatePaths, 2500));
    };
    secreteDiffuseBtn.onclick = () => {
      secreteProtein();
      secretePathBtn.disabled = secreteDiffuseBtn.disabled = true;
      timers.push(setTimeout(propagateDiffuse, 2500));
    };
  </script>
</body>
</html>
