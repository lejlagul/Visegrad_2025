<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D signalling modell</title>

  <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
  <script src="https://raw.githack.com/andreasplesch/aframe-meshline-component/master/dist/aframe-meshline-component.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/3.4.7/aframe/build/aframe-ar.js"></script>

  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin:0; overflow:hidden; font-family:monospace; }
    #status { position:fixed; top:10px; left:10px; font-size:24px; color:#fff; z-index:1000; }
    #controls { position:fixed; bottom:12px; left:12px; z-index:1000; }
    #controls button {
      margin-right:8px;
      padding:6px 12px;
      font:16px monospace;
      background:#222; color:#fff;
      border:1px solid #888; border-radius:4px;
      opacity:0.85;
    }
    #loader {
      position:fixed; inset:0;
      display:flex; flex-direction:column;
      justify-content:center; align-items:center;
      background:#000;
    }
    .spinner {
      width:48px; height:48px;
      border:6px solid #fff;
      border-top-color:transparent;
      border-radius:50%;
      animation:spin 1s linear infinite;
    }
    @keyframes spin { to { transform:rotate(360deg); } }
  </style>
</head>

<body>
  <div id="loader">
    <div class="spinner"></div>
    <p style="color:#fff; margin-top:12px;">Loading camera…</p>
  </div>
  <div id="status">Searching…</div>
  <div id="controls">
    <button id="startBtn">Start signal</button>
    <button id="resetBtn">Reset signal</button>
  </div>

  <a-scene embedded arjs="sourceType: webcam; debugUIEnabled:false;">
    <a-marker id="hiroMarker" preset="hiro" emitevents="true">
      <a-entity id="cell" visible="false" drag-rotate></a-entity>
    </a-marker>
    <a-entity camera></a-entity>
  </a-scene>

  <script>
  // drag-rotate component
  AFRAME.registerComponent('drag-rotate', {
    schema: { speed: { default: 1 } },
    init() {
      const canvas = this.el.sceneEl.canvas;
      let dragging = false, px = 0, py = 0;
      const start = e => { dragging = true; px = e.clientX; py = e.clientY; };
      const move = (x,y,f=1) => {
        if (!dragging) return;
        const r = this.el.getAttribute('rotation');
        this.el.setAttribute('rotation', {
          x: r.x + (y - py) * f * this.data.speed,
          y: r.y + (x - px) * f * this.data.speed,
          z: r.z
        });
        px = x; py = y;
      };
      canvas.addEventListener('mousedown', e => start(e));
      window.addEventListener('mousemove', e => move(e.clientX, e.clientY));
      window.addEventListener('mouseup', () => dragging = false);
      canvas.addEventListener('touchstart', e => start(e.touches[0]), { passive: false });
      window.addEventListener('touchmove', e => {
        if (dragging) { e.preventDefault(); move(e.touches[0].clientX, e.touches[0].clientY, 0.5); }
      }, { passive: false });
      window.addEventListener('touchend', () => dragging = false);
    }
  });
  </script>

  <script>
    // scene elements
    const scene      = document.querySelector('a-scene');
    const marker     = document.getElementById('hiroMarker');
    const cell       = document.getElementById('cell');
    const statusBox  = document.getElementById('status');
    const loader     = document.getElementById('loader');
    const startBtn   = document.getElementById('startBtn');
    const resetBtn   = document.getElementById('resetBtn');

    // network constants
    const N_NODES       = 50;
    const PROP_INTERVAL = 1200;  // ms
    const LINE_WIDTH    = 16;

    // data storage
    const nodes  = [];   // { id, x, y, z, el }
    const edges  = [];   // { id, a, b, el }
    let timers   = [];

    // add cell & organelles
    function addOrganelles() {
      cell.insertAdjacentHTML('beforeend', `
        <a-box width="1.6" height="1.6" depth="1.6"
               material="color:#00ffff;opacity:0.10;transparent:true;side:double"></a-box>
        <a-sphere radius="0.45"
                  material="color:#800080;opacity:0.50;transparent:true"></a-sphere>
      `);
      [0.55,0.42,0.34].forEach((w,i) => {
        cell.insertAdjacentHTML('beforeend', `
          <a-box width="${w}" height="0.05" depth="${(w*0.58).toFixed(2)}"
                 position="-0.55 ${(0.25 - i*0.08).toFixed(2)} 0"
                 material="color:#cd853f;opacity:0.80"></a-box>
        `);
      });
      [['0.55 -0.33 0.25','0 0 90'],['0.48 0.40 -0.30','60 30 20']].forEach(m => {
        cell.insertAdjacentHTML('beforeend', `
          <a-cylinder radius="0.12" height="0.45"
                     position="${m[0]}" rotation="${m[1]}"
                     material="color:#ff8c00;opacity:0.85"></a-cylinder>
        `);
      });
    }

    // build 50-node graph
    function rnd(a,b){ return Math.random()*(b-a)+a; }

    function buildNetwork() {
      // receptor on top
      nodes.push({ id:'n0', x:0, y:0.80, z:0 });
      while (nodes.length < N_NODES) {
        nodes.push({
          id:`n${nodes.length}`,
          x:rnd(-0.6,0.6),
          y:rnd(-0.6,0.6),
          z:rnd(-0.6,0.6)
        });
      }
      // create spheres
      nodes.forEach(n => {
        cell.insertAdjacentHTML('beforeend', `
          <a-sphere id="${n.id}" radius="0.06" color="#888"
                    position="${n.x} ${n.y} ${n.z}"></a-sphere>
        `);
        n.el = document.getElementById(n.id);
      });
      // connect to 3 nearest later nodes
      nodes.forEach((n,i) => {
        const list = nodes.map((m,j)=>( { j, d:Math.hypot(n.x-m.x,n.y-m.y,n.z-m.z) } ))
                          .sort((a,b)=>a.d-b.d);
        let added=0;
        for (let k=1; k<list.length && added<3; k++) {
          const j=list[k].j;
          if (j < i) continue;
          const id   = `e${edges.length}`;
          const path = `${n.x} ${n.y} ${n.z}, ${nodes[j].x} ${nodes[j].y} ${nodes[j].z}`;
          cell.insertAdjacentHTML('beforeend', `
            <a-entity id="${id}"
                      meshline="lineWidth:${LINE_WIDTH};path:${path};color:#666"></a-entity>
          `);
          edges.push({ id, a:i, b:j, el:document.getElementById(id) });
          added++;
        }
      });
    }

    // reset colours
    function resetColours(nodeCol, edgeCol) {
      nodes.forEach(n => n.el.setAttribute('color', nodeCol));
      edges.forEach(e => {
        const ml = e.el.getAttribute('meshline');
        e.el.setAttribute('meshline',
          ml.replace(/color:[^;]+/, `color:${edgeCol}`));
      });
    }

    // propagate signal
    function propagate() {
      // clear timers, reset colours to grey
      timers.forEach(clearTimeout); timers=[];
      resetColours('#888', '#666');

      // BFS waves
      const visited = new Set([0]);
      const waves   = [[0]];
      while (waves[waves.length-1].length) {
        const next = [];
        waves[waves.length-1].forEach(i => {
          edges.forEach(e => {
            const nb = (e.a===i? e.b : e.b===i? e.a : null);
            if (nb!==null && !visited.has(nb)) {
              visited.add(nb);
              next.push(nb);
            }
          });
        });
        if (next.length) waves.push(next);
        else break;
      }
      // animate waves
      waves.forEach((wave, w)=> {
        timers.push(setTimeout(()=> {
          wave.forEach(i => nodes[i].el.setAttribute('color','#ff0000'));
          edges.forEach(e => {
            const ca = nodes[e.a].el.getAttribute('color'),
                  cb = nodes[e.b].el.getAttribute('color');
            if (ca==='#ff0000' && cb==='#ff0000') {
              const ml = e.el.getAttribute('meshline');
              e.el.setAttribute('meshline',
                ml.replace(/color:[^;]+/, 'color:#ff0000'));
            }
          });
        }, w * PROP_INTERVAL));
      });
    }

    // reset network
    function resetNetwork() {
      timers.forEach(clearTimeout); timers=[];
      resetColours('#888', '#666');
    }

    // build once scene loads
    scene.addEventListener('loaded', () => {
      loader.style.display = 'none';
      addOrganelles();
      buildNetwork();
      resetNetwork();
    });

    // marker events
    marker.addEventListener('markerFound', () => {
      cell.setAttribute('visible', true);
      statusBox.textContent = 'Success';
    });
    marker.addEventListener('markerLost', () => {
      cell.setAttribute('visible', false);
      statusBox.textContent = 'Searching…';
      resetNetwork();
    });

    // control buttons
    startBtn.addEventListener('click', () => {
      if (cell.getAttribute('visible')) {
        propagate();
      }
    });
    resetBtn.addEventListener('click', () => {
      resetNetwork();
      // restart immediately
      if (cell.getAttribute('visible') === 'true') {
        propagate();
      }
    });
  </script>
</body>
</html>
